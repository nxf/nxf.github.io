<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Spring cloud</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_介绍.html"><strong aria-hidden="true">1.</strong> 简介</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01_Parent.html"><strong aria-hidden="true">1.1.</strong> 父项目搭建</a></li></ol></li><li class="chapter-item expanded "><a href="02_Eureka.html"><strong aria-hidden="true">2.</strong> Eureka</a></li><li class="chapter-item expanded "><a href="03_Ribbon_Hystrix.html"><strong aria-hidden="true">3.</strong> Ribbon&Hystrix</a></li><li class="chapter-item expanded "><a href="04_Feign.html"><strong aria-hidden="true">4.</strong> Feign</a></li><li class="chapter-item expanded "><a href="05_Gateway.html"><strong aria-hidden="true">5.</strong> Gateway</a></li><li class="chapter-item expanded "><a href="06_Config.html"><strong aria-hidden="true">6.</strong> Config</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="06_Config_Rabbit_install.html"><strong aria-hidden="true">6.1.</strong> Rabbit安装</a></li></ol></li><li class="chapter-item expanded "><a href="07_Sleuth.html"><strong aria-hidden="true">7.</strong> Sleuth</a></li><li class="chapter-item expanded "><a href="08_Admin.html"><strong aria-hidden="true">8.</strong> Admin</a></li><li class="chapter-item expanded "><a href="09_合同录入-上.html"><strong aria-hidden="true">9.</strong> 合同录入-上</a></li><li class="chapter-item expanded "><a href="10_合同录入-下.html"><strong aria-hidden="true">10.</strong> 合同录入-下</a></li><li class="chapter-item expanded "><a href="11_支付中心-上.html"><strong aria-hidden="true">11.</strong> 支付中心-上</a></li><li class="chapter-item expanded "><a href="12_支付中心-下.html"><strong aria-hidden="true">12.</strong> 支付中心-下</a></li><li class="chapter-item expanded "><a href="13_预约看房.html"><strong aria-hidden="true">13.</strong> 预约看房</a></li><li class="chapter-item expanded "><a href="14_RocketMQ-上.html"><strong aria-hidden="true">14.</strong> RocketMQ入门</a></li><li class="chapter-item expanded "><a href="15_RocketMQ-下.html"><strong aria-hidden="true">15.</strong> RocketMQ集群</a></li><li class="chapter-item expanded "><a href="16_预约看房消息推送.html"><strong aria-hidden="true">16.</strong> 预约看房消息推送</a></li><li class="chapter-item expanded "><a href="17_外卖抢单-上.html"><strong aria-hidden="true">17.</strong> 外卖抢单-上</a></li><li class="chapter-item expanded "><a href="18_外卖抢单-下.html"><strong aria-hidden="true">18.</strong> 外卖抢单-下</a></li><li class="chapter-item expanded "><a href="19_企业级测试与解决方案.html"><strong aria-hidden="true">19.</strong> 企业级测试与解决方案</a></li><li class="chapter-item expanded "><a href="20_结项.html"><strong aria-hidden="true">20.</strong> 结项</a></li><li class="chapter-item expanded "><a href="project/index.html"><strong aria-hidden="true">21.</strong> 项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="project/aijia/aijia.html"><strong aria-hidden="true">21.1.</strong> 爱家家具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="project/aijia/analyze.html"><strong aria-hidden="true">21.1.1.</strong> 分析</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="resources.html">基础资源</a></li><li class="chapter-item expanded affix "><a href="mysql.html">mysql</a></li><li class="chapter-item expanded affix "><a href="redis.html">redis</a></li><li class="chapter-item expanded affix "><a href="security.html">security</a></li><li class="chapter-item expanded affix "><a href="front.html">前端</a></li><li class="chapter-item expanded affix "><a href="other.html">其他零碎</a></li><li class="chapter-item expanded affix "><a href="mail.html">邮件</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Spring cloud</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="课程简介"><a class="header" href="#课程简介">课程简介</a></h1>
<h2 id="总体内容"><a class="header" href="#总体内容">总体内容</a></h2>
<pre class="mermaid">graph LR
专高四 --&gt; C[Spring Cloud微服务架构*]
专高四 --&gt; T[其它技术]
专高四 --&gt; W[维数公寓]
专高四 --&gt; M[外卖抢单]
专高四 --&gt; Q[企业级测试与解决方案]
</pre>
<h2 id="spring-cloud"><a class="header" href="#spring-cloud">Spring Cloud</a></h2>
<pre class="mermaid">graph LR
C[spring_cloud微服务架构] --注册中心--&gt; Eureka

C --负载均衡--&gt; Ribbon
C --服务容错--&gt; Hystrix
C --声明式远程服务调用--&gt; OpenFeign
C --网关--&gt; Gateway
C --配置服务--&gt; Config
C --消息总线--&gt; Bus
C --请求链接追踪--&gt; Sleuth
C --状态监控--&gt; Admin
C --网关安全--&gt; Security
</pre>
<h2 id="其它技术"><a class="header" href="#其它技术">其它技术</a></h2>
<pre class="mermaid">graph LR
T[其它技术]
T --消息队列--&gt; RocketMQ
T --消息队列--&gt; RabbitMQ
T --缓存--&gt; Redis
T --分布式任务平台--&gt; XXL-Job
T --接口测试与调试工具--&gt; PostMan
T --压力&amp;&amp;性能--&gt; JMeter
</pre>
<h2 id="维数公寓"><a class="header" href="#维数公寓">维数公寓</a></h2>
<pre class="mermaid">graph LR

维数公寓 --&gt; 合同录入
维数公寓 --&gt; 预约看房
维数公寓 --&gt; 支付中心

外卖服务 --&gt; 外卖抢单
</pre>
<h1 id="作业"><a class="header" href="#作业">作业：</a></h1>
<p>上传作业内容和效果视频（3分钟左右）；</p>
<p>作业检查表：</p>
<pre class="mermaid">graph LR
组长 --&gt; 组员
讲师 -- 抽检 --&gt; 学员
</pre>
<h1 id="参考资料"><a class="header" href="#参考资料">参考资料：</a></h1>
<p><a href="https://www.macrozheng.com/cloud/cloud_catalog.html#%E7%AE%80%E4%BB%8B">SpringCloud参考</a></p>
<h1 id="时间"><a class="header" href="#时间">时间</a></h1>
<p><img src="./imgs/2101A.jpg" alt="本月" />
<img src="./imgs/time-summer.jpg" alt="每天" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="父项目搭建"><a class="header" href="#父项目搭建">父项目搭建</a></h1>
<p>Spring Cloud有很多版本，本课程选取Hoxton.RELEASE版本，它依赖的Spring boot版本为2.2.5.RELEASE。</p>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;

&lt;properties&gt;
    &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
    &lt;springcloud.version&gt;Hoxton.RELEASE&lt;/springcloud.version&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!--lombok--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;!--控制spring cloud系列的版本--&gt;
&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
            &lt;version&gt;${springcloud.version}&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;!--springboot 插件--&gt;
&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.5.6&lt;/version&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p>普通项目需要引入web依赖，如下：</p>
<pre><code class="language-xml">&lt;!--gateway中不能引入！--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一eureka介绍"><a class="header" href="#一eureka介绍">一，Eureka介绍</a></h1>
<p>注册服务中心</p>
<pre class="mermaid">flowchart TD
C[服务消费者] --发现--&gt;  E[Eureka]
P[服务提供者] --注册 --&gt; E[Eureka]
</pre>
<p>服务消费者 和 服务提供者 都属于 Eureka客户端。<br />
Eureka 就是Eureka服务端。</p>
<h2 id="作用"><a class="header" href="#作用">作用</a></h2>
<ul>
<li>类似于114查号台的作用， Eureka就是114查号台， 服务提供者就是商家，服务消费者就是别的商家或消费者，服务提供者将信息登记到114，服务消费者会去114查询商家的联系方式。</li>
</ul>
<h1 id="二搭建server端eureka"><a class="header" href="#二搭建server端eureka">二，搭建Server端(eureka)</a></h1>
<p>具体步骤如下：</p>
<h2 id="1-添加依赖"><a class="header" href="#1-添加依赖">1. 添加依赖</a></h2>
<p>在pom中添加依赖</p>
<pre><code class="language-xml">&lt;!--eureka服务依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="2-按开关"><a class="header" href="#2-按开关">2. 按开关</a></h2>
<pre><code class="language-java">//放在启动类上方
@EnableEurekaServer
</code></pre>
<h2 id="3-加配置"><a class="header" href="#3-加配置">3. 加配置</a></h2>
<pre><code class="language-yaml">#顶格放
eureka:
  instance:
    ip-address: 127.0.0.1
    prefer-ip-address: true
  server:
    enable-self-preservation: false #是否开启自我保护，防止网络分区故障时删掉微服务
  client:
    fetch-registry: false #是否从注册中心获取注册表
    register-with-eureka: false #是否要注册到注册中心
</code></pre>
<h1 id="二搭建client端housecontract等"><a class="header" href="#二搭建client端housecontract等">二，搭建Client端(house,contract等)</a></h1>
<p>搭建步骤：</p>
<h2 id="1添加依赖"><a class="header" href="#1添加依赖">1.添加依赖</a></h2>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!--注册中心（eureka）客户端依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="2按开关"><a class="header" href="#2按开关">2.按开关</a></h2>
<pre><code class="language-java">//放在启动类上方
@EnableEurekaClient
</code></pre>
<h2 id="3加配置"><a class="header" href="#3加配置">3.加配置</a></h2>
<pre><code class="language-yaml">#顶格放
eureka:
  instance:
    prefer-ip-address: true # 优先使用ip地址
    ip-address: 127.0.0.1 # 使用这个ip
#    instance-id: user # 显示实例名称
  client:
    register-with-eureka: true # 注册到eureka
    fetch_registry: true #从服务器获取注册信息
    service-url:
      defaultZone: http://localhost:8761/eureka/ # 注册中心地址
</code></pre>
<h1 id="三搭建eureka集群"><a class="header" href="#三搭建eureka集群">三，搭建eureka集群</a></h1>
<p>当只有一个Eureka服务的时候，如果这个服务宕机，就会导致整个系统崩溃，所以需要搭建一个Eureka服务集群，提高服务的稳定性。</p>
<h2 id="1-添加配置文件"><a class="header" href="#1-添加配置文件">1. 添加配置文件</a></h2>
<p>假设我们要创建两个服务的集群，则先创建两个配置文件，如下：</p>
<ul>
<li>application-01.yml </li>
<li>application-02.yml</li>
</ul>
<p>然后修改配置中的eureka的配置，修改后如下所示</p>
<pre><code class="language-yaml">eureka:
  instance:
    ip-address: 127.0.0.1
    prefer-ip-address: true
  server:
    enable-self-preservation: false #是否开启自我保护，防止网络分区故障时删掉微服务
  client:
    fetch-registry: true #是否从注册中心获取注册表; 这里需要获取，所以改为true
    register-with-eureka: true #是否要注册到注册中心； 需要注册到注册中心，所以改为true
    service-url:
      defaultZone: http://localhost:8762/eureka/,http://localhost:8761/eureka/ #两个服务互相指向对方

</code></pre>
<h2 id="修改idea的运行配置文件"><a class="header" href="#修改idea的运行配置文件">修改idea的运行配置文件</a></h2>
<p>在IDEA中配置启动入口时，指定要使用的配置文件，例如下面的配置指定使用application-01.yml配置文件。</p>
<p><img src="./imgs/jiqun_230616.png" alt="idea-edit-configuration" /></p>
<h1 id="四用security保护-eureka"><a class="header" href="#四用security保护-eureka">四，用security保护 eureka</a></h1>
<p>任何用户都可以访问Eureka服务会有安全性隐患，所以一般会在Eureka服务端添加安全保护措施。</p>
<h2 id="加依赖"><a class="header" href="#加依赖">加依赖</a></h2>
<p>在Eureka服务的pom中添加依赖。</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="配置文件中添加用户名和密码"><a class="header" href="#配置文件中添加用户名和密码">配置文件中添加用户名和密码</a></h2>
<p>在Eureka的application.yml文件中添加security配置</p>
<pre><code class="language-yaml">spring:
  application:
    name: eureka
  security: # 一定要注意对齐关系，security和application平级
    user: # 指定spring security的登录
      name: admin
      password: 123456
</code></pre>
<h2 id="添加安全设置"><a class="header" href="#添加安全设置">添加安全设置</a></h2>
<p>在Eureka服务中添加以下配置类，放开向eureka的注册请求。</p>
<pre><code class="language-java">@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        //csrf -&gt; Cross-Site Request Forgery  跨站请求伪造
        http.csrf().ignoringAntMatchers(&quot;/eureka/**&quot;); //ignore是忽略的意思
        super.configure(http);
    }
}
</code></pre>
<h2 id="eureka客户端添加认证信息"><a class="header" href="#eureka客户端添加认证信息">Eureka客户端添加认证信息</a></h2>
<p>格式： 用户名:密码@url</p>
<pre><code class="language-yaml">defaultZone: http://macro:123456@localhost:8761/eureka # 注册中心地址
</code></pre>
<p>注意，无论是我们示例中的house，contract还是eureka服务本身，只要他想向被security保护的eureka服务端注册都需要带上上面的用户名和密码配置。</p>
<h1 id="其它eureka常用配置"><a class="header" href="#其它eureka常用配置">其它eureka常用配置</a></h1>
<pre><code class="language-yaml">
eureka:
  client:
    register-with-eureka: true #是否将自己注册到eureka服务
    fetch-registry: true  #是否从eureka服务获取注册信息
    service-url:
      defaultZone: http://localhost:8761/eureka/  #服务地址，逗号分隔
    registry-fetch-interval-seconds: 30  #多久去服务端取一次注册信息
  instance:
    lease-renewal-interval-in-seconds: 30 #续约间隔，秒
    lease-expiration-duration-in-seconds: 90 #过期间隔 ，秒
    prefer-ip-address: true  #优先使用ip地址而非主机名称
    ip-address: 127.0.0.1
  server:
    enable-self-preservaation: false  #开启自我保护
### 打开services面板
</code></pre>
<h1 id="打开service窗口"><a class="header" href="#打开service窗口">打开service窗口：</a></h1>
<p><img src="./imgs/unit_1-idea-service.jpg" alt="查看运行的服务" /></p>
<h1 id="五常见错误"><a class="header" href="#五常见错误">五、常见错误：</a></h1>
<ol>
<li>添加security配置时，security和application没有上下对齐。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一resttemplate"><a class="header" href="#一resttemplate">一，RestTemplate</a></h1>
<p>使用之前需要先定义一个RestTemplate的实例，方便别的地方注入：</p>
<pre><code class="language-java">@Configuration
public class MyRestTemplateConfig {
    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
</code></pre>
<p>之后通过如下方式使用：</p>
<pre><code class="language-java">// 通过ip地址（域名）直接访问
AllType allType =  restTemplate.getForObject(&quot;http://localhost:8081/type/&quot;, AllType.class);

</code></pre>
<p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html">restTemplate api参考</a></p>
<h2 id="举个例子"><a class="header" href="#举个例子">举个例子：</a></h2>
<p>首先定义一个被调用服务入口，这里是 http://localhost:8081/getName/2</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/&quot;)
public class HouseController {

    
    @GetMapping(&quot;/getName/{id}&quot;)
    public String getName(@PathVariable int id) {
        System.out.println(&quot;====================&quot;);
        return &quot;房屋id=&quot;+id;
    }
}
</code></pre>
<p>然后在定义了RestTemplate的项目中定义对被调用服务的访问：</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/contract&quot;)
public class ContractController {

    @Autowired
    RestTemplate restTemplate;
    //http://ip:port/conteact/test-rest?id=1
    @RequestMapping(&quot;test-rest&quot;)
    public String tesRest(int id) {
        String forObject = restTemplate.getForObject(&quot;http://localhost:8081/getName/&quot; + id, String.class);
        return forObject;
    }
}
</code></pre>
<h1 id="二ribbon"><a class="header" href="#二ribbon">二，Ribbon</a></h1>
<p>微服务架构中会有服务实例间的互相调用，实例之间的远程调用可能需要使用RestTemplate来进行。当被调用的服务部署多个实例后，请求需要公平的发送到这些实例（负载均衡），这时
就需要Ribbon来帮助RestTemplate来实现。</p>
<p>Ribbon 负载均衡策略</p>
<ul>
<li>com.netflix.loadbalancer.RandomRule //随机</li>
<li>com.netflix.loadbalancer.RoundRobinRule //轮询</li>
<li>com.netflix.loadbalancer.RetryRule //轮询的基础上加上重试</li>
<li>com.netflix.loadbalancer.WeightedResponseTimeRule //轮询的基础上加上响应时间权重</li>
<li>com.netflix.loadbalancer.BestAvailableRule //并发最小</li>
<li>com.netflix.loadbalancer.AvailabilityFilteringRule //过滤掉故障实例，并发最小</li>
<li>com.netflix.loadbalancer.ZoneAwareLoadBalancer //考虑到区域相同</li>
</ul>
<h2 id="添加ribbon依赖"><a class="header" href="#添加ribbon依赖">添加ribbon依赖</a></h2>
<pre><code class="language-xml">&lt;!-- 负载均衡 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="增加被调用服务的实例"><a class="header" href="#增加被调用服务的实例">增加被调用服务的实例</a></h2>
<p>上节课已经配置过Eureka集群（高可用），步骤大致如下：</p>
<ul>
<li>增加配置文件,例如：application-02.yml</li>
<li>添加运行入口，右上角 Edit Configuration</li>
<li>运行入口中指定使用的配置文件 Active Profiles</li>
</ul>
<h2 id="使用负载均衡"><a class="header" href="#使用负载均衡">使用负载均衡</a></h2>
<p>修改RestTemplate实例定义，增加负载均衡能力。</p>
<pre><code class="language-java">@Configuration
public class MyRestTemplateConfig {
    @Bean
    @LoadBalanced //为RestTemplate添加负载均衡能力，
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
</code></pre>
<h2 id="修改resttemplate对远程服务的访问方式"><a class="header" href="#修改resttemplate对远程服务的访问方式">修改restTemplate对远程服务的访问方式</a></h2>
<p>将原来对某ip地址的访问改成对服务的访问，restTemplate会在运行时将服务名称改为服务名对应的ip地址。</p>
<pre><code class="language-java">// 接入eureka和ribbon后, RestTemplate在发起调用前会将type替换为真是的服务器地址
AllType allType =  restTemplate.getForObject(&quot;http://type/type/&quot;, AllType.class);
</code></pre>
<h2 id="更换ribon负载均衡算法"><a class="header" href="#更换ribon负载均衡算法">更换ribon负载均衡算法</a></h2>
<pre><code class="language-java">@Bean
IRule myRule() {
    return new RandomRule();
}
</code></pre>
<p>上述代码需要放在 @Configuration修饰的类中。</p>
<h1 id="三hystrix---熔断与降级"><a class="header" href="#三hystrix---熔断与降级">三，Hystrix - 熔断与降级</a></h1>
<p>负责服务的熔断与降级,考虑如下的服务调用：</p>
<p><img src="./imgs/hystrix.png" alt="服务调用" /></p>
<h2 id="引入依赖"><a class="header" href="#引入依赖">引入依赖</a></h2>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="按开关"><a class="header" href="#按开关">按开关</a></h2>
<pre><code class="language-java">//二选一
//@EnableCircuitBreaker
@EnableHystrix
</code></pre>
<h2 id="hystrixcommand"><a class="header" href="#hystrixcommand">HystrixCommand</a></h2>
<h3 id="使用方法"><a class="header" href="#使用方法">使用方法</a></h3>
<p>在需要实现服务降级的方法上添加注解 @HystrixCommand . 
然后配置 fallbackMethod 属性，其参数为发生异常时要降级到的方法的名称，此降级方法需要与
@HystrixCommand修饰的方法返回类型及参数保持一致。</p>
<h3 id="hystrixcommand参数介绍"><a class="header" href="#hystrixcommand参数介绍">HystrixCommand参数介绍</a></h3>
<ul>
<li>fallbackMethod：指定服务降级处理方法；</li>
<li>ignoreExceptions：忽略某些异常，不发生服务降级； </li>
</ul>
<h4 id="fallbackmethod-回调方法"><a class="header" href="#fallbackmethod-回调方法">fallbackMethod （回调方法）</a></h4>
<pre><code>指定降级到的方法，此方法的返回类型及参数需要与@HystrixCommand修饰的方法返回类型及参数保持一致。
</code></pre>
<h4 id="ignoreexceptions-忽略异常"><a class="header" href="#ignoreexceptions-忽略异常">ignoreExceptions （忽略异常）</a></h4>
<p>指定忽略掉某些异常，设置忽略这些异常后，在发生这些异常后不会进行降级处理。</p>
<pre><code class="language-java">@HystrixCommand(fallbackMethod = &quot;fallback&quot;, ignoreExceptions = {NullPointerException.class})
public String getName(@PathVariable int id) {
    System.out.println(&quot;====================&quot;);
    if(1==1){
        throw new NullPointerException();
    }
    return &quot;房屋id=&quot;+id;
}

//降级方法，返回值及参数需要和上面被HystrixCommand修饰的方法保持一致，方法名就是上面fallbackMethod指定的方法名。
public String fallback(@PathVariable int id) {
    return &quot;降级方法id=&quot;+id;
}
</code></pre>
<h3 id="扩展--熔断状态"><a class="header" href="#扩展--熔断状态">扩展--熔断状态</a></h3>
<pre class="mermaid">graph LR;
N[关闭状态]--有异常--&gt;V{验证}
V--10S_and_50%--&gt;S[启动状态]
S--所有请求直接进入--&gt;F((fallback))
R{重试}--重试失败--&gt;F
S --5秒后--&gt; R
R---一旦请求成功则关闭熔断---&gt;N
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feign简介"><a class="header" href="#feign简介">Feign简介</a></h1>
<p>相比RestTemplate，Feign是更好更方便的远程访问工具。</p>
<h1 id="一基本使用"><a class="header" href="#一基本使用">一，基本使用</a></h1>
<h2 id="加依赖-1"><a class="header" href="#加依赖-1">加依赖</a></h2>
<pre><code class="language-xml">&lt;!-- eureka客户端 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!-- Feign依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="按开关-1"><a class="header" href="#按开关-1">按开关</a></h2>
<p>在入口类上添加注解：</p>
<pre><code class="language-java">@EnableFeignClients
</code></pre>
<h2 id="添加配置"><a class="header" href="#添加配置">添加配置</a></h2>
<p>如果没有添加eureka配置的需要添加此配置：</p>
<pre><code class="language-yaml">eureka:
  instance:
    prefer-ip-address: true
    ip-address: 127.0.0.1
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      defaultZone: http://localhost:8761/eureka/
</code></pre>
<h2 id="代码"><a class="header" href="#代码">代码</a></h2>
<pre><code class="language-java">//调用方接口定义
//这里的name=&quot;house&quot;表示被调用方的服务名称
@FeignClient(name=&quot;house&quot;, path = &quot;house&quot;, fallback = HouseFeignServiceFallback.class)
public interface HouseFeignService {

    @GetMapping(&quot;/{id}&quot;)
    public House getHouse(@PathVariable int id);

}

</code></pre>
<pre><code class="language-java">//被调用方代码
@RestController
@RequestMapping(&quot;/house&quot;)
public class HouseWithReqMappingController {

    @GetMapping(&quot;/{id}&quot;)
    public House getHouse(@PathVariable int id) {
        System.out.println(&quot;======================&quot;);
        House house = new House();
        house.setId(1);
        house.setName(&quot;房屋with_mapping&quot;);
        return house;
    }
}
</code></pre>
<p>两者之间的对应关系如下图中红色标识：
<img src="./imgs/feign.png" alt="调用和被调用放配置关系" /></p>
<h1 id="二负载均衡"><a class="header" href="#二负载均衡">二，负载均衡</a></h1>
<p>负载均衡使用ribbon来实现，所以修改负载均衡和上一节ribbon的修改方法一样。</p>
<pre><code class="language-java">//注意，需要放在被@Configuration修饰的类中
@Bean
public IRule myRule() {
    return new RandomRule();
}
</code></pre>
<h1 id="三feign的服务降级"><a class="header" href="#三feign的服务降级">三，Feign的服务降级</a></h1>
<p>Feign也支持服务降级，本质上它就是使用上节课学习的Hystrix来实现的。</p>
<h2 id="修改feign接口"><a class="header" href="#修改feign接口">修改Feign接口</a></h2>
<p>添加降级类，降级类会在发生异常时接管处理。</p>
<pre><code class="language-java">@FeignClient(name=&quot;house&quot;, fallback = HouseFeignServiceFallback.class)
</code></pre>
<h2 id="新建降级fallback类"><a class="header" href="#新建降级fallback类">新建降级fallback类</a></h2>
<p>降级类要实现上面定义的接口，并实现降级方法，另外注意在降级类上添加@Service注解，以纳入spring管理</p>
<pre><code class="language-java">@Service
public class OrderServiceCallback implements OrderServiceFeign{
    @Override
    public Integer getOrderNumberOfUser(Long id) {
        return 22;
    }

    @Override
    public Map postOrderNumberOfUser(Long id) {
        Map result = new HashMap();
        result.put(&quot;number&quot;,23);

        return result;
    }
}

</code></pre>
<h2 id="改配置"><a class="header" href="#改配置">改配置</a></h2>
<p>因为feign也是使用hystrix实现的降级，且默认没有打开降级支持，所以这里需要打开hystrix功能：</p>
<pre><code class="language-yaml">feign:
  hystrix:
    enabled: true
</code></pre>
<h1 id="四打开日志"><a class="header" href="#四打开日志">四，打开日志</a></h1>
<p>打开Feign调用日志，方便查找问题。</p>
<pre><code class="language-java">//注意，需要放在被@Configuration修饰的类中
@Bean
Logger.Level feignLogLevel() {
    return Logger.Level.FULL;
}
</code></pre>
<p>同时，需要配置yml文件中的日志等级。</p>
<pre><code class="language-yaml">logging:
  level:
    org.example.service: debug
</code></pre>
<h1 id="五常用配置"><a class="header" href="#五常用配置">五，常用配置</a></h1>
<h2 id="压缩"><a class="header" href="#压缩">压缩</a></h2>
<p>客户端</p>
<pre><code class="language-yaml">feign:
  hystrix:
    enabled: true
  compression:
    response:
      enabled: true
    request:
      enabled: true
      min-request-size: 2048  # 超过2M则进行压缩
</code></pre>
<h2 id="超时配置"><a class="header" href="#超时配置">超时配置</a></h2>
<p>在Feign配置超时时，真正的超时降级受两个地方的配置约束：</p>
<pre><code class="language-yaml">feign:
  client:
    config:
      default:
        read-timeout: 10000   # feign配置的读超时配置
  hystrix:
    enabled: true

hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 30000   #hystrix配置的超时配置
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gateway-简介"><a class="header" href="#gateway-简介">gateway 简介</a></h1>
<p>如果没有gateway，网页需要分别访问 house contract服务。
各服务还需要分别实现安全，流量控制。</p>
<h1 id="一基础使用"><a class="header" href="#一基础使用">一，基础使用</a></h1>
<p>网关的作用-》 路由； 安全； 流量控制</p>
<h2 id="1添加依赖-1"><a class="header" href="#1添加依赖-1">1.添加依赖</a></h2>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="2路由配置"><a class="header" href="#2路由配置">2.路由配置</a></h2>
<h3 id="21-通过配置文件配置路由"><a class="header" href="#21-通过配置文件配置路由">2.1 通过配置文件配置路由</a></h3>
<pre><code class="language-yaml">spring:
  application:
    name: gateway-server
  cloud:
    gateway:
      routes:
        - id: user
#          uri: http://localhost:8083  #直接指定服务器地址，不推荐
          uri: lb://user # 指定服务器注册实例名
          filters: #在请求被转向后端服务之前可以进行更改。
            - StripPrefix=1 # 去掉前缀过滤器
          predicates: #断言，只有满足断言的请求才会被放过去。
            - Path=/services/**  # 如果访问路径以services开头，则执行本路由规则

eureka: # 顶格：另外记得入口类添加@EnableEurekaClient
  instance:
    ip-address: 127.0.0.1
    prefer-ip-address: true
  client:
    fetch-registry: true
    register-with-eureka: true
    service-url:
      defaultZone: http://localhost:8761/eureka/
</code></pre>
<h3 id="22-通过代码配置路由"><a class="header" href="#22-通过代码配置路由">2.2 通过代码配置路由</a></h3>
<p>一般不使用，了解就好。</p>
<pre><code class="language-java">@Configuration
public class GatewayConfig {

    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        StripPrefixGatewayFilterFactory factory = new StripPrefixGatewayFilterFactory();
        StripPrefixGatewayFilterFactory.Config config = new StripPrefixGatewayFilterFactory.Config();
        config.setParts(1);
        GatewayFilter stripFilter = factory.apply(config);
        return builder.routes()
                .route(&quot;user&quot;, r-&gt; r.path(&quot;/services/**&quot;)
                        .filters(gatewayFilterSpec -&gt; gatewayFilterSpec.filter(stripFilter))
                        .uri(&quot;lb://user&quot;))
                .build();
    }
}
</code></pre>
<h3 id="23-概念解析"><a class="header" href="#23-概念解析">2.3 概念解析：</a></h3>
<p>路由中涉及到两个重要的新概念，断言和过滤器。</p>
<h4 id="断言"><a class="header" href="#断言">断言</a></h4>
<p>断言就是判断，用来决定某个请求是不是应该由当前配置中的服务器来处理。我们最常用的就是Path断言，它是根据请求路径进行判断的。</p>
<h4 id="过滤器"><a class="header" href="#过滤器">过滤器</a></h4>
<p>过滤器是对将要交给后端服务的请求进行进一步处理的地方。常用的是StripPrefix，一般和Path断言配合使用，用来将为了路由请求添加的路径去掉。</p>
<h3 id="24-负载均衡"><a class="header" href="#24-负载均衡">2.4 负载均衡</a></h3>
<p>可以使用ribbon对路由进行负载均衡算法的自定义：</p>
<pre><code class="language-yaml">message:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule

</code></pre>
<h2 id="3-实例讲解"><a class="header" href="#3-实例讲解">3. 实例讲解</a></h2>
<p>假设我们有house服务，有如下配置和代码：</p>
<pre><code class="language-yml">server:
  port: 8081 

spring:
  application:
    name: house
</code></pre>
<p>以上配置确定house服务的访问端口是8081。 以下代码决定了访问路径为 /house/list</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/house&quot;)
public class HouseController {
    
    @GetMapping(&quot;/list&quot;) 
    public Result&lt;IPage&lt;House&gt;&gt; list(@RequestParam Integer page, @RequestParam(required = false) Integer size) {
       int _size = size != null ? size : defaultSize;
        IPage&lt;House&gt; ipage = new Page&lt;&gt;(page, _size);
        houseService.page(ipage);
        return Result.ok(ipage);
    }
</code></pre>
<p>综合以上信息我们可以得出，通过house服务自己的端口访问list的url应该为：</p>
<p>http://localhost:8091/house/list?page=1&amp;size=10</p>
<p>如果要通过网关访问，则再假设我们的gateway网关路由配置如下：</p>
<pre><code class="language-yml">server:
  port: 8080
spring:
  application:
    name: gateway
  
  cloud:
    gateway:
      routes:
        - id: house
          #          uri: http://localhost:8083  #直接指定服务器地址，不推荐
          uri: lb://house # 指定服务器注册实例名
          filters: #对请求进行进一步处理
            - StripPrefix=1 # 去掉前缀过滤器
          predicates: #断言
            - Path=/order/**  # 如果访问路径以services开头，则执行本路由规则
</code></pre>
<p>则最终通过网关的访问路径为</p>
<pre><code>http://localhsot:8080/house/house/list?page=1&amp;size=10
</code></pre>
<p>当这样一个请求到达网关时具体的处理流程是怎样的呢？</p>
<ul>
<li>首先经过断言判断，因为请求路径 <em>/house/house/list?page=1&amp;size=10</em> 满足 正则表达式 */house/** *,所以该请求将会被转到house服务处理</li>
<li>过滤器StripPrefix=1，表示要将请求路径的前1级路径去掉，则经过处理后请求路径变为 <em>/house/list?page=1&amp;size=10</em></li>
<li>因为已经没有别的过滤器，所以请求被转到house服务</li>
<li>house服务刚好有处理 <em>house/list?page=1&amp;size=10</em> 请求的方法，则访问成功被处理。</li>
</ul>
<h1 id="二route-predicate-一些常见断言"><a class="header" href="#二route-predicate-一些常见断言">二，Route Predicate 一些常见断言</a></h1>
<ul>
<li>Path Route Predicate
<pre><code class="language-yaml"> - Path=/user/{id} # curl http://localhost:8080/services/another/1
</code></pre>
</li>
<li>Method Route Predicate
访问方法断言
<pre><code class="language-yaml">- Method=GET # curl http://localhost:8080/services/another/1
</code></pre>
</li>
<li>Header Route Predicate 
请求头路由
<pre><code class="language-yaml">  - Header=X-Request-Id,\d+ # curl http://localhost:8080/services/another/1 -H X-Request-Id:88
</code></pre>
</li>
<li>Cookie Route Predicate
Cookie路由断言
<pre><code class="language-yaml">  - Cookie=sessionId,test # curl http://localhost:8080/services/another/1 --cookie sessionId=test
</code></pre>
</li>
<li>Query Route Predicate
请求参数路由
<pre><code class="language-yaml">  - Query=name,pu. # http://localhost:8080/services/another/5?name=pu1 参数以name命名，值以pu开始共三位 
</code></pre>
</li>
<li>RemoteAddr Route Predicate
远端地址路由断言</li>
</ul>
<pre><code class="language-yaml">- RemoteAddr=192.168.1.1/24

</code></pre>
<ul>
<li>Host Route Predicate
主机地址路由</li>
</ul>
<pre><code class="language-yaml">- Host=**.baidu.com #
</code></pre>
<ul>
<li>Before Route Predicate</li>
</ul>
<pre><code class="language-yaml">- Before=2022-10-24T16:30:00+08:00[Asia/Shanghai]
</code></pre>
<ul>
<li>After Route Predicate</li>
</ul>
<pre><code class="language-yaml">- After=2019-09-24T16:30:00+08:00[Asia/Shanghai]
</code></pre>
<ul>
<li>Between Route Predicate</li>
</ul>
<pre><code class="language-yaml">- Between=2019-09-24T16:30:00+08:00[Asia/Shanghai],2023-09-24T16:30:00+08:00[Asia/Shanghai] 
</code></pre>
<h1 id="三filter"><a class="header" href="#三filter">三，Filter</a></h1>
<p>部分过滤器</p>
<ul>
<li>AddRequestParameter</li>
</ul>
<pre><code class="language-yaml">  cloud:
    gateway:
      routes:
        - id: user
          uri: lb://user
          filters:
            - StripPrefix=1
            - AddRequestParameter=username,bw00 
</code></pre>
<ul>
<li>StripPrefix</li>
</ul>
<pre><code class="language-yaml">  cloud:
    gateway:
      routes:
        - id: user
          uri: lb://user
          filters:
            - StripPrefix=1
</code></pre>
<ul>
<li>PrefixPath</li>
</ul>
<pre><code class="language-yaml">cloud:
  gateway:
    routes:
      - id: user
        uri: lb://user
        filters:
          - StripPrefix=1
          - PrefixPath=/another
        predicates:
          - Path=/services/**
</code></pre>
<ul>
<li>Hystrix
除了之前Hystrix在单独的微服务中使用以外，Hystrix还可以在网关中使用。先添加依赖：</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
&lt;/dependency&gt; 
</code></pre>
<p>编写降级处理代码：</p>
<pre><code class="language-java">@RestController
@RequestMapping
public class IndexController {

    @GetMapping(&quot;/badthinghappend&quot;)
    public ResponseEntity fallback4Another() {
        return ResponseEntity.ok(&quot;badthinghappend &quot;);
    }
}
</code></pre>
<p>然后通过配置确定当异常发生时将请求降级到上面的路径来处理：</p>
<pre><code class="language-yaml">          filters:
            - StripPrefix=1
            - name: Hystrix
              args:
                name: fallbackcmd
                fallbackUri: forward:/badthinghappend
</code></pre>
<ul>
<li>RequestRateLimiter
请求速率限制是一个重要的技能点，需要重点学习下。因为速率限制需要redis记录一些数据，所以需要先添加依赖:</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>然后还得添加redis配置：</p>
<pre><code class="language-yaml">spring:
  redis:
    host: localhost
    port: 6379
</code></pre>
<p>最后在配置中添加过相关配置</p>
<pre><code class="language-yaml">    filters:
      - name: RequestRateLimiter
        args:
          redis-rate-limiter.replenishRate: 1 # 放令牌的速率
          redis-rate-limiter.burstCapacity: 2 # 令牌桶最大放多少个
          redis-rate-limiter.requestedTokens: 20 #每次请求消耗几个令牌（3.0以上支持）
          key-resolver: &quot;#{@ipKeyResolver}&quot; # 根据userName来限流
</code></pre>
<p>上面的ipKeyResolver会引用项目中定义的实例，该实例需要在项目中定义，如下：：</p>
<pre><code class="language-java">@Configuration
public class RedisRateLimiterConfig {

  @Bean
  KeyResolver ipKeyResolver() {
    return new KeyResolver(){

      @Override
      public Mono&lt;String&gt; resolve(ServerWebExchange exchange) {
        return Mono.just(exchange.getRequest().getRemoteAddress().getHostString());
      }
    };
  }
}
</code></pre>
<h2 id="四全局过滤器global-filters"><a class="header" href="#四全局过滤器global-filters">四，全局过滤器(Global Filters)</a></h2>
<p>添加global Filter定义</p>
<pre><code class="language-java">@Slf4j
@Component
public class LogGlobalFilter implements GlobalFilter, Ordered {
    @Override
    public int getOrder() {
        return 10;
    }

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String path = exchange.getRequest().getPath().value();
        log.info(&quot;有人访问了: &quot; + path);
        return chain.filter(exchange);
    }
}
</code></pre>
<h1 id="五cors-配置"><a class="header" href="#五cors-配置">五，CORS 配置</a></h1>
<p>注意！！！，在网关添加了跨域后，后面微服务自己添加的跨域需要去掉，否则会出错。</p>
<pre><code class="language-yaml">spring:
  cloud:
    gateway:
      globalcors:
        cors-configurations:
          '[/**]':
            allowedOrigins: &quot;*&quot;
            allowedHeaders: &quot;*&quot;
            allowedMethods: &quot;*&quot;
            allowCredentials: true
            maxAge: 360000
</code></pre>
<h1 id="六常见错误"><a class="header" href="#六常见错误">六，常见错误</a></h1>
<ol>
<li>在gateway的pom文件或父pom文件中引入web依赖：</li>
</ol>
<pre><code class="language-xml">&lt;!--gateway中不能引入！--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一spring-cloud-config"><a class="header" href="#一spring-cloud-config">一，Spring Cloud Config</a></h1>
<h2 id="示意图"><a class="header" href="#示意图">示意图</a></h2>
<p><img src="imgs/config.png" alt="cnfig架构图" /></p>
<h2 id="git仓库"><a class="header" href="#git仓库">git仓库</a></h2>
<p>示例：
<a href="https://gitee.com/nixf/config-repo.git">config-repo</a>
各位同学要创建自己的repo。</p>
<h3 id="创建步骤简要描述"><a class="header" href="#创建步骤简要描述">创建步骤简要描述：</a></h3>
<ul>
<li>创建仓库</li>
<li>创建文件夹</li>
<li>在文件夹中创建 user-dev.yml文件</li>
<li>回到仓库首页，点击管理</li>
<li>在管理页面下方找到<em>开源</em>选项并选中</li>
<li>提交后即可访问</li>
</ul>
<h1 id="二config服务端配置"><a class="header" href="#二config服务端配置">二，Config服务端配置</a></h1>
<h2 id="新建config项目"><a class="header" href="#新建config项目">新建config项目</a></h2>
<h2 id="添加依赖"><a class="header" href="#添加依赖">添加依赖</a></h2>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="入口类加注解"><a class="header" href="#入口类加注解">入口类加注解</a></h2>
<pre><code class="language-java">@EnableConfigServer
</code></pre>
<h1 id="配置文件添加"><a class="header" href="#配置文件添加">配置文件添加</a></h1>
<pre><code class="language-yaml">spring:
  cloud:
    config:
      server:
        git: #配置存储信息的Git仓库
          #username: xxx
          #password: 123456
          uri: https://gitee.com/nixf/config-repo.git  # 仓库地址
          clone-on-start: true # 启动时直接从gitee获取数据
          search-paths: unit_5 # 搜索目录
          default-label: master # 默认的分支
      label: master #分支信息
</code></pre>
<h2 id="测试"><a class="header" href="#测试">测试</a></h2>
<p>测试config服务器配置是否生效，以如下所示格式访问</p>
<p><a href="http://localhost:8888/user/dev/master">http://localhost:8888/application_name/profile/branch_name</a></p>
<p>application_name:  指应用的注册名
profile： 环境（dev,test,product) 
branch_name: git分支名</p>
<p>以我们创建git仓库时建的文件user-dev.yml为例，对它的内容访问路径为：</p>
<pre><code>http:localhost:8888/user/dev/master
</code></pre>
<p>可以在user-dev.yml中添加内容后再查看效果。</p>
<h1 id="三客户端配置"><a class="header" href="#三客户端配置">三，客户端配置</a></h1>
<h2 id="添加依赖-1"><a class="header" href="#添加依赖-1">添加依赖</a></h2>
<pre><code class="language-xml">&lt;!--此jar包会读取bootstrap.yml，给应用使用config服务的机会 --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;
  &lt;version&gt;3.1.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>新建bootstrap.yml</p>
<pre><code class="language-yaml">server:
  port: 9092 #修改为你安排的端口

spring:
  application:
    name: message # 修改为你应用的注册名
  cloud:
    config:
      profile: dev # 指定开发环境，还可以是test product等。
      label: master # git分支
      uri: http://localhost:8888  #config 服务地址
      name: user    #当前应用名，用于匹配git内的配置文件
</code></pre>
<p>演示对git中配置文件定义的属性的访问。</p>
<pre><code class="language-java">//（6-1）
@RestController
@RefreshScope
public class ConfigController {

    //读取配置中的值，此值只在git内有
    @Value(&quot;${my-name}&quot;)
    private String myName;

    @GetMapping(&quot;/my-name&quot;)
    public String getConfigName() {
        return myName;
    }

}
</code></pre>
<h2 id="刷新"><a class="header" href="#刷新">刷新</a></h2>
<p>刷新需要使用actuator的refresh端口。
<a href="http://localhost:8888/actuator/refresh">http://localhost:8888/actuator/refresh</a></p>
<h3 id="添加actuator依赖"><a class="header" href="#添加actuator依赖">添加actuator依赖</a></h3>
<pre><code class="language-xml">		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
		&lt;/dependency&gt;
</code></pre>
<h3 id="同时打开refresh端口"><a class="header" href="#同时打开refresh端口">同时打开refresh端口</a></h3>
<pre><code class="language-yaml">management:
  endpoints:
    web:
      exposure:
        include: 'refresh'
</code></pre>
<p>也可以打开全部端口：</p>
<pre><code class="language-yaml">management:
  endpoints:
    web:
      exposure:
        include: '*'
</code></pre>
<h3 id="refreshscope"><a class="header" href="#refreshscope">@RefreshScope</a></h3>
<p>注意上面例子（6-1）的@RefreshScope注解，它对于使用自定义变量在通过接口通知后自动刷新本地变量至关重要。</p>
<h1 id="四config-高可用"><a class="header" href="#四config-高可用">四，config 高可用</a></h1>
<p>配置config高可用后，就不能再指定一个url路径了，需要使用eureka的帮助自动匹配服务地址。</p>
<pre><code class="language-yaml">  cloud:
    config:
      profile: dev
      lable: master
#      uri: http://localhost:8888
      name: user
      discovery: # 启用自动寻址
        enabled: true # 打开为TRUE
        service-id: config  # config的服务ID--即eureka的注册名
eureka:
  instance:
    prefer-ip-address: true
    ip-address: 127.0.0.1
  #    instance-id: user
  client:
    register-with-eureka: true # 注册到eureka
    fetch_registry: true #从服务器获取注册信息
    service-url:
      defaultZone: http://localhost:8761/eureka/ # 注册中心地址        
</code></pre>
<h1 id="五spring-cloud-bus"><a class="header" href="#五spring-cloud-bus">五，Spring Cloud Bus</a></h1>
<p>Spring Cloud Bus需要使用RabbitMQ帮助。 参见 <a href="./06_Config_Rabbit_install.html">Rabbit安装</a></p>
<p>RabbitMQ的相关概念</p>
<ul>
<li>Broker  消息队列服务</li>
<li>Connection   publisher 和 consumer 与broker的tcp连接</li>
<li>Channel 逻辑连接</li>
<li>Exchange 分发消息 p2p topic multicast/fanout</li>
<li>Queue 真正的消息队列</li>
<li>Binding exchange和queue之间的虚拟连接</li>
</ul>
<p>MQ通用概念：</p>
<pre class="mermaid">graph LR

Publisher --发送消息--&gt; Broker
Broker --推消息--&gt; Receiver
Receiver --拉消息--&gt; Broker
</pre>
<p>Config服务和Config客户端接入Spring Cloud Bus后，我们可以只通知Config服务更新配置，即可实现所有的客户端都自动更新配置的目的。
步骤如下：</p>
<h2 id="config-server配置"><a class="header" href="#config-server配置">config server配置</a></h2>
<p>服务端需要接入rammbitMQ,所以增加以下依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;

</code></pre>
<p>同时，配置文件中添加rabbitMQ的配置。同时打开bus-refresh端口，通过此端口通知Config服务刷新配置。</p>
<pre><code class="language-yaml">spring:
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest

management:
  endpoints:
    web:
      exposure:
        include: 'bus-refresh'  # config服务端开发端口，通过post访问
</code></pre>
<h2 id="config-client配置"><a class="header" href="#config-client配置">config client配置</a></h2>
<p>Config 客户端也需要接入RabbitMQ。添加依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>添加配置文件：</p>
<pre><code class="language-yaml">spring:
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest

</code></pre>
<h2 id="测试-1"><a class="header" href="#测试-1">测试</a></h2>
<p>更改git的配置后，使用Post方法调用
http://localhost:8888/actuator/bus-refresh 即可更新所有通过bus链接到config服务的配置。</p>
<h1 id="六config服务器安全"><a class="header" href="#六config服务器安全">六，Config服务器安全</a></h1>
<h2 id="引进安全jar包"><a class="header" href="#引进安全jar包">引进安全jar包：</a></h2>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="设置服务的用户名和密码"><a class="header" href="#设置服务的用户名和密码">设置服务的用户名和密码：</a></h2>
<pre><code class="language-yaml">spring:
  application:
    name: config
  security:
    user:
      name: admin
      password: 123456
</code></pre>
<h2 id="放开刷新接口的访问"><a class="header" href="#放开刷新接口的访问">放开刷新接口的访问：</a></h2>
<pre><code class="language-java">@Configuration
public class SecurityConfig  extends WebSecurityConfigurerAdapter {

    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests().anyRequest()
                .authenticated()
                .and().httpBasic().and().csrf().disable();
    }

}
</code></pre>
<p>客户端添加安全配置：</p>
<pre><code class="language-yaml">  cloud:
    config: # house-dev.yml
      profile: dev # 指定开发环境，还可以是test product等。
      label: master # git分支
#      uri: http://localhost:8888  #config 服务地址
      name: house    #当前应用名，用于匹配git内的配置文件
      discovery: # 启用自动寻址
        enabled: true # 打开为TRUE
        service-id: config  # config的服务ID--即eureka的注册名
      username: admin
      password: 123456
</code></pre>
<p>使用Postman刷新：
<img src="./imgs/config-security-refresh.png" alt="Postman刷新配置" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rabbit-安装"><a class="header" href="#rabbit-安装">Rabbit 安装</a></h1>
<p>rabbitMQ 是基于Erlang语言开发的，因此在安装rabbit之前需要先安装erlang。
安装时需要注意几点：</p>
<pre><code>1，文件路径不要有中文、空格；
2，计算机名不要有中文
</code></pre>
<h2 id="erlang-安装"><a class="header" href="#erlang-安装">Erlang 安装</a></h2>
<p>官网：https://www.erlang.org/downloads<br />
<img src="./imgs/rabbit/erlang.png" alt="erlang官网" /></p>
<p>下载地址： http://erlang.org/download/otp_win32_21.3.exe</p>
<h3 id="配置erlang环境变量"><a class="header" href="#配置erlang环境变量">配置Erlang环境变量</a></h3>
<p>新建系统变量：</p>
<pre><code class="language-shell">ERLANG_HOME
C:\Program Files\erl-24.2
</code></pre>
<p>将bin追加到Path变量中</p>
<pre><code class="language-shell">%ERLANG_HOME%\bin
</code></pre>
<h3 id="测试erlang环境"><a class="header" href="#测试erlang环境">测试Erlang环境</a></h3>
<pre><code class="language-shell">erl
</code></pre>
<p><img src="./imgs/rabbit/erl_run.png" alt="erlang运行测试" /></p>
<h2 id="下载rabbitmq"><a class="header" href="#下载rabbitmq">下载RabbitMQ</a></h2>
<p><img src="./imgs/rabbit/rabbit.png" alt="rabbit官网" />
rabbitMQ下载： https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.14</p>
<p>安装管理插件：</p>
<p>在rabbit的sbin目录下执行：</p>
<pre><code class="language-shelll">rabbitmq-plugins enable rabbitmq_management
</code></pre>
<p>安装完成后访问： http://localhost:15672/
<img src="./imgs/rabbit/rabbit_login.png" alt="rabbit console" />
用户名和密码： guest/guest</p>
<h2 id="问题解决"><a class="header" href="#问题解决">问题解决</a></h2>
<p>再次确认安装路径中没有空格，中文字符。
再次确认当前用户名不是中文。 确认后进行以下操作。</p>
<ol>
<li>以上操作都按照步骤执行了，还是不能访问。
打开系统服务，找到RabbitMQ，重新启动。</li>
<li>还是不行。
执行</li>
</ol>
<pre><code class="language-shell">rabbitmq-plugins list
</code></pre>
<p>查看rabbitmq_management 确实安装了。如果确实安装了
在执行
rabbitmq-service stop
rabbitmq-service start</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sleuth-简介"><a class="header" href="#sleuth-简介">Sleuth 简介</a></h1>
<p>请求追踪，问题（性能，异常）定位</p>
<h1 id="一-给服务添加链路追踪"><a class="header" href="#一-给服务添加链路追踪">一， 给服务添加链路追踪</a></h1>
<h2 id="加依赖-2"><a class="header" href="#加依赖-2">加依赖</a></h2>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="添加配置-1"><a class="header" href="#添加配置-1">添加配置</a></h2>
<pre><code class="language-yaml">spring:
  zipkin: # 指定zipkin服务器地址
    base-url: http://localhost:9411
  sleuth:
    sampler: # 采样器
      probability: 0.1 # 设置Sleuth抽样收集的概率

</code></pre>
<h2 id="安装zipkin"><a class="header" href="#安装zipkin">安装zipkin</a></h2>
<p>主页地址： <a href="https://zipkin.io/">https://zipkin.io/</a>
<img src="./imgs/zipkin_download.png" alt="zipkin下载" />
下载后使用如下命令启动zipkin：</p>
<pre><code class="language-shell">  java -jar zipkin-server-2.23.19-exec.jar
</code></pre>
<h3 id="zipkin概念"><a class="header" href="#zipkin概念">zipkin概念</a></h3>
<ul>
<li>span-跨度-范围</li>
<li>trace-追踪-痕迹</li>
</ul>
<h2 id="使用es持久化存储跟踪信息"><a class="header" href="#使用es持久化存储跟踪信息">使用ES持久化存储跟踪信息</a></h2>
<ul>
<li>安装ES</li>
<li>ES Header
chrome 安装 /Volumes/workspace/es-head/es-head</li>
<li>zipkin启动时传入使用ES的参数</li>
</ul>
<pre><code class="language-shell"># STORAGE_TYPE：表示存储类型 ES_HOSTS：表示ES的访问地址
java -jar zipkin-server-2.12.9-exec.jar --STORAGE_TYPE=elasticsearch --ES_HOSTS=localhost:9200

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spring-boot-admin"><a class="header" href="#spring-boot-admin">Spring Boot Admin</a></h1>
<p>Spring Boot Admin  通过  Actuator 获得应用运行过程中的各项指标。以图形化界面展示出来。监控以下内容：</p>
<ul>
<li>应用概览信息</li>
<li>度量指标信息</li>
<li>环境变量信息</li>
<li>所有创建的Bean信息</li>
<li>查看应用中所有配置信息</li>
<li>应用运行日志信息</li>
<li>查看JVM信息</li>
<li>查看可以访问的Web端点</li>
<li>查看HTTP跟踪信息</li>
<li></li>
</ul>
<h1 id="一-admin-server"><a class="header" href="#一-admin-server">一 admin-server</a></h1>
<p>新建admin项目，按照以下步骤添加依赖和配置。</p>
<h2 id="1添加依赖-2"><a class="header" href="#1添加依赖-2">1.添加依赖</a></h2>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;
    &lt;version&gt;2.2.4&lt;/version&gt; 
&lt;/dependency&gt;
</code></pre>
<h2 id="2打开开关"><a class="header" href="#2打开开关">2.打开开关</a></h2>
<pre><code class="language-java">@EnableAdminServer
</code></pre>
<h2 id="3配置"><a class="header" href="#3配置">3.配置</a></h2>
<pre><code class="language-yaml">server:
  port: 9301
spring:
  application:
    name: admin-server
</code></pre>
<p>访问http://localhost:9301查看效果</p>
<h1 id="二-admin-client"><a class="header" href="#二-admin-client">二 admin-client</a></h1>
<p>选择（或新建）项目，作为admin client接入admin服务。</p>
<h2 id="1-引依赖"><a class="header" href="#1-引依赖">1. 引依赖</a></h2>
<pre><code class="language-xml">&lt;!--admin客户端--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;
    &lt;version&gt;2.2.4&lt;/version&gt; &lt;!--2.6.2不兼容 --&gt;
&lt;/dependency&gt;
&lt;!-- 开启监控接口--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="2-配置"><a class="header" href="#2-配置">2. 配置</a></h2>
<p>spring.boot.admin.client.url 告诉admin server地址
management 开启查询端口</p>
<pre><code class="language-yaml">spring:
  boot:
    admin:
      client:
        url: http://localhost:9301 #配置admin-server地址
management:
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    health:
      show-details: always
logging:
  file: # 开启admin的日志监控
    name: admin-client.log

</code></pre>
<p>启动后，再次查看admin服务，可以观察到接入服务的相关信息。</p>
<h1 id="三-演示"><a class="header" href="#三-演示">三 演示</a></h1>
<ul>
<li>1 访问监控地址
http://localhost:9301</li>
<li>2 点击wallboard按钮，选择要监控的实例查看详情</li>
<li>3 度量指标信息 JVM，Tomcat及进程信息</li>
<li>4 环境变量信息</li>
<li>5 所有的Bean信息</li>
<li>6 查看应用中的所有配置信息</li>
<li>7 查看日志信息</li>
</ul>
<h1 id="四-结合注册中心"><a class="header" href="#四-结合注册中心">四 结合注册中心</a></h1>
<p>上面的配置中我们指定了admin服务的地址，这样admin服务地址变更时就比较麻烦，所以我们可以使用eureka来实现动态查找admin服务。</p>
<h2 id="admin-server的修改"><a class="header" href="#admin-server的修改">Admin Server的修改</a></h2>
<p>首先需要引入eureka client依赖和添加相应配置。</p>
<h3 id="添加eureka-client"><a class="header" href="#添加eureka-client">添加eureka-client</a></h3>
<pre><code class="language-xml">&lt;dependency&gt;
 &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
 &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="打开eurekaclient"><a class="header" href="#打开eurekaclient">打开EurekaClient</a></h3>
<pre><code class="language-java">@EnableEurekaClient
</code></pre>
<h3 id="添加注册中心配置"><a class="header" href="#添加注册中心配置">添加注册中心配置</a></h3>
<pre><code class="language-yaml">
eureka:
  client:
    fetch-registry: true #指定是否要从注册中心获取服务（注册中心不需要开启）
    register-with-eureka: true #指定是否要注册到注册中心（注册中心不需要开启）
    # 需要注意，如果eureka服务开始了security保护，这里需要有用户名和密码
    # http://username:password@localhost:8761/eureka/
    #集群的配置
    #defaultZone: http://node1:8761/eureka,http://node2:8762/eureka,http://node3:8763/eureka
    #单机的配置
    service-url:
      defaultZone: http://localhost:8761/eureka/

</code></pre>
<h2 id="admin-client"><a class="header" href="#admin-client">Admin Client</a></h2>
<pre><code class="language-yaml">management: # Admin 通过 actuator提供的端口进行监控系统，因此需要打开各端口
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    health:
      show-details: always
logging:
  file: # 开启admin的日志监控
    name: admin-client.log

</code></pre>
<h1 id="五-添加登陆认证"><a class="header" href="#五-添加登陆认证">五 添加登陆认证</a></h1>
<p>引入安全依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>配置用户名和密码</p>
<pre><code class="language-yaml">spring:
  security:
    user:
      name: xxx
      password: 123456
    boot:
      admin:
        discovery:
          ignored-services: ${spring.application.name} # 忽略自己的信息

</code></pre>
<p>增加security后，对于没有使用eureka注册中心，直接去通知admin的就
会受到影响，需要对security进行配置，以允许admin-client对admin的请求。</p>
<p>Spring Security</p>
<pre><code class="language-java">@Configuration
public class SecuritySecureConfig extends WebSecurityConfigurerAdapter {
  private final String adminContextPath;
  public SecuritySecureConfig(AdminServerProperties adminServerProperties) {
    this.adminContextPath = adminServerProperties.getContextPath();
  }
 @Override
 protected void configure(HttpSecurity http) throws Exception {
  SavedRequestAwareAuthenticationSuccessHandler successHandler = new SavedRequestAwareAuthenticationSuccessHandler();
  successHandler.setTargetUrlParameter(&quot;redirectTo&quot;);
  successHandler.setDefaultTargetUrl(adminContextPath + &quot;/&quot;);
  http.authorizeRequests()
   //1.配置所有静态资源和登录页可以公开访问
  .antMatchers(adminContextPath + &quot;/assets/**&quot;).permitAll()
  .antMatchers(adminContextPath + &quot;/login&quot;).permitAll()
  .antMatchers(adminContextPath+&quot;/instances&quot;).permitAll()
  .antMatchers(adminContextPath+&quot;/actuator/**&quot;).permitAll()
  .anyRequest().authenticated()
  .and()
   //2.配置登录和登出路径
  .formLogin().loginPage(adminContextPath + &quot;/login&quot;).successHandler(successHandler).and()
  .logout().logoutUrl(adminContextPath + &quot;/logout&quot;).and()
  //3.开启 http basic 支持，admin-client 注册时需要使用
  .httpBasic().and()
  .csrf()
  //4.开启基于 cookie 的 csrf 保护
  .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
  //5.忽略这些路径的 csrf 保护以便 admin-client 注册
  .ignoringAntMatchers(adminContextPath + &quot;/instances&quot;,adminContextPath + &quot;/actuator/**&quot;);
 }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="合同录入"><a class="header" href="#合同录入">合同录入</a></h1>
<p>环境复杂度</p>
<ul>
<li>[合同编号重复]</li>
</ul>
<pre><code class="language-java">    Snowflake snowflake = IdUtil.getSnowflake();
    String id = &quot;HT&quot;+snowlake.nextId();
</code></pre>
<ul>
<li>[身份证号码格式不正确]</li>
</ul>
<pre><code class="language-javascript">/^\d{6}(18|19|20)?\d{2}(0[1-9]|1[012])(0[1-9]|[12]\d|3[01])\d{3}(\d|[xX])$/
</code></pre>
<ul>
<li>租客身份证和租客姓名不真实
<a href="https://market.aliyun.com/products/57000002/cmapi025518.html#sku=yuncode1951800000">api服务入口</a></li>
</ul>
<pre><code class="language-java">    @PostMapping(&quot;/verify&quot;)
    public Result&lt;Boolean&gt; verify(@RequestBody Contract contract) {
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;idNo&quot;, contract.getIdNo());
        map.put(&quot;name&quot;, contract.getName());
        String body = HttpRequest.post(&quot;https://idenauthen.market.alicloudapi.com/idenAuthentication&quot;)
                .header(&quot;Authorization&quot;, &quot;APPCODE b30006ab97e44f33b9398fd90094e676&quot;)
                .form(map)
                .execute()
                .body();
        System.out.println(body);
        int index = body.indexOf(&quot;身份证信息匹配&quot;);
        return Result.ok(index&gt;0);
    }
</code></pre>
<ul>
<li>[计算合同金额精度缺失]</li>
<li>主要涉及BigDecimal的计算。</li>
</ul>
<pre><code class="language-java">        BigDecimal first = BigDecimal.valueOf(10.22);
        BigDecimal second = BigDecimal.valueOf(8);

        BigDecimal sum = first.add(second);
        BigDecimal subtract = first.subtract(second);
        BigDecimal subtract2 = second.subtract(first);
        BigDecimal multiply = first.multiply(second);
        BigDecimal divide = first.divide(second);

        boolean bigger = first.compareTo(second) &gt; 0;
        boolean equal = first.compareTo(BigDecimal.valueOf(10.220)) == 0;
        boolean less = second.compareTo(first) &lt; 0;
</code></pre>
<ul>
<li>[签合同期间房屋被租出去]</li>
</ul>
<pre><code class="language-java">//TODO 
</code></pre>
<h2 id="收房合同录入功能"><a class="header" href="#收房合同录入功能">收房合同录入功能</a></h2>
<ul>
<li>合同信息录入</li>
<li>合同录入选择房产</li>
<li>附件处理</li>
<li>付款单生成</li>
</ul>
<h2 id="表设计"><a class="header" href="#表设计">表设计</a></h2>
<h2 id="合同信息录入"><a class="header" href="#合同信息录入">合同信息录入</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="合同录入下"><a class="header" href="#合同录入下">合同录入下：</a></h1>
<ul>
<li>[房间租赁合同和客户身份证上传失败]
大文件时涉及断点上传</li>
<li>[网络请求被篡改]
服务端验证请求、计算金额
[应收房款分期计算有误差]<br />
使用BigDecimal
[租房合同保存失败，数据不完整]
事务</li>
</ul>
<h1 id="文件上传-minio"><a class="header" href="#文件上传-minio">文件上传 MinIO</a></h1>
<p><a href="http://min.io/download#/windows">MinIO</a></p>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<p>参考视频
<a href="./imgs/minio%E5%AE%89%E8%A3%85%E7%B2%BE%E7%AE%80%E7%89%88.mp4">安装MiniO</a></p>
<h2 id="启动命令"><a class="header" href="#启动命令">启动命令：</a></h2>
<pre><code class="language-shell">   minio.exe server D:\tmp\minio
</code></pre>
<p>其中 D:\tmp\minio 是图片存储根目录。需要根据自己的情况设置。</p>
<h2 id="添加依赖-2"><a class="header" href="#添加依赖-2">添加依赖</a></h2>
<pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;io.minio&lt;/groupId&gt;
   &lt;artifactId&gt;minio&lt;/artifactId&gt;
   &lt;version&gt;7.0.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="上传示例代码"><a class="header" href="#上传示例代码">上传示例代码</a></h2>
<p><a href="https://min.io/docs/minio/linux/developers/java/API.html">MiniO文档</a></p>
<pre><code class="language-java">    private final String BUCKET_NAME = &quot;2010a&quot;;

    @PostMapping(&quot;/upload&quot;)
    public Result&lt;String&gt; upload(MultipartFile file) throws InvalidPortException, InvalidEndpointException, IOException, InvalidBucketNameException, InsufficientDataException, ErrorResponseException, NoSuchAlgorithmException, InvalidKeyException, InvalidResponseException, XmlParserException, InternalException {
        //改写名字，但是不能改写类型；
        String name = file.getOriginalFilename(); // a.jpg;
        name = name.substring(name.indexOf(&quot;.&quot;)); //.jpg
        name = IdUtil.getSnowflakeNextIdStr()+name;// 随机数 + .jpg
         //修改为自己服务器上的key和secret。
        MinioClient minioClient = new MinioClient(&quot;http://localhost:9000&quot;, &quot;ExgAQimtkr6sKLWW&quot;, &quot;OyWuId4T1SqzMjJpZ9u8AQX2YL0Rm8Nq&quot;);

        PutObjectOptions options = new PutObjectOptions(file.getSize(), 11111111);
        options.setContentType(file.getContentType());

        minioClient.putObject(BUCKET_NAME, name, file.getInputStream(), options);


        String url = &quot;http://localhost:9000/&quot;+BUCKET_NAME+&quot;/&quot;+name;

        return Result.ok(url);
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="环境介绍"><a class="header" href="#环境介绍">环境介绍</a></h1>
<h2 id="沙箱环境"><a class="header" href="#沙箱环境">沙箱环境</a></h2>
<p>在我们的学习，考试中主要使用这个环境的信息，包含appId，支付网关地址，签名等信息。
<a href="https://open.alipay.com/develop/sandbox/app?is_switch_sandbox=true">沙箱环境</a></p>
<h2 id="文档中心"><a class="header" href="#文档中心">文档中心</a></h2>
<p><a href="https://opendocs.alipay.com/open/028r8t?ref=api&amp;scene=22">https://opendocs.alipay.com/open/028r8t?ref=api&amp;scene=22</a></p>
<h2 id="调试中心"><a class="header" href="#调试中心">调试中心</a></h2>
<p>调试中心包含各api的调用例子，使我们开发学习的主要参考：
<a href="https://open.alipay.com/dev/workspace/apidebug" title="支付宝调试">https://open.alipay.com/dev/workspace/apidebug</a></p>
<h2 id="代码示例"><a class="header" href="#代码示例">代码示例</a></h2>
<p>jsp示例，这里包含有文档中心及调试中心都不存在的支付回调验签代码。
<a href="https://opendocs.alipay.com/open/270/106291">支付回调验签</a></p>
<h2 id="管理平台"><a class="header" href="#管理平台">管理平台</a></h2>
<p>正式的开发需要创建应用，并使用它的appId等信息，但是现在不是必须使用它。
<a href="https://open.alipay.com/develop/manage">创建应用</a></p>
<h2 id="内网穿透工具"><a class="header" href="#内网穿透工具">内网穿透工具</a></h2>
<p>支付宝支付成功后有个回调地址，因为支付宝只能访问外网地址，所以我们或者自己部署到云服务器，或者使用内网穿透工具提供外网地址。
如下是两个（类）常用的穿透工具。</p>
<h3 id="花生壳"><a class="header" href="#花生壳">花生壳</a></h3>
<pre><code>需要去线上认证下：
</code></pre>
<p><a href="https://hsk.oray.com/">https://hsk.oray.com/</a></p>
<h3 id="ngrok"><a class="header" href="#ngrok">ngrok</a></h3>
<pre><code>版本众多，可用的不多。
</code></pre>
<h1 id="开发"><a class="header" href="#开发">开发</a></h1>
<h2 id="依赖"><a class="header" href="#依赖">依赖</a></h2>
<p>首先需要引进依赖的jar包。</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alipay.sdk&lt;/groupId&gt;
    &lt;artifactId&gt;alipay-sdk-java&lt;/artifactId&gt;
    &lt;version&gt;4.33.50.ALL&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="配置"><a class="header" href="#配置">配置</a></h2>
<p>使用从沙箱环境获得的信息配置AliClient。</p>
<pre><code class="language-java">@Configuration
public class AlipayConfiguration {

    @Bean
    public static AlipayClient alipayClient() {
        AlipayConfig config = new AlipayConfig();
        //支付宝测试环境服务器
        config.setServerUrl(&quot;https://openapi.alipaydev.com/gateway.do&quot;);
        //支付宝应用id，在沙箱环境内获取
        config.setAppId(&quot;2016092100560986&quot;);
        //引用私钥，建议使用《支付宝开放平台开发助手》生成，RSA2
        config.setPrivateKey(&quot;MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCLq2XQiqUVyxyO+vT3VIXOhIGWvL1SIs9p28kurzgXzV8JR0X2h+TrSjfyjwYRQH9aV5FFy9NIciA1ce0ZPfxniDt4Bs0pHqLJfkRaUhkotVWn8F6kqqoypy1NfLseDx8GsGXnWVST0wV7xpeOlQM6cflVwYTxx5topyZc5u6NbLssdb/DX1ABjsMsinJQpbgutJFYwy+iWIM7MTSOds4FwZpWdowZ824zfqCMyWibiP1JmguXVcl14eWyOv6LDvDe0niXiF2qMDrTUReVVb+XwEsGb1/cdJT9wU0JDreRH1SSwE6Z+sQdQClfqB/WQJZniveugGf4bXnnZRQfo44fAgMBAAECggEAH7dCHYL+Td6bk5RFQEy/PdA1JSeizh39f4pbOvCrCiymohK/PmZJg2yNG9WCiTReNwOfh3vrdI4F5l0CfDLpOBFlf7H7sJS2Xo7/sormD6pt0v7wXvAqSepQjUH/s6m3X+t6mHhejlri6eKE0+nem8z505FoQQcUsUUTnxEJpq9s1f8SxVF0+6v2va2UqyCbPwKIR0bQLLF7K8a2jl2YBaHRntRi7BCqt4z+IQmHkI6M1zDOysSVbeVX3XlAc54nseorSHAY3ywmjkFSPmBc5MDzNSFgSG2IdHzlTU7R2F4wvExbFGPh64UODzlwcyZFYaTVwUdxhS8JxyXsnHTsQQKBgQDjJs/CMee4AWTN9GNj3XfVW29xjta7XGFJh5BaQRuABpI10nfNyadfwHC7PxjauGqHX2TTpc6991m+kaHOdX5nUyjMOAkhIrmJT1xgPHEjr15Enzp5f8L9NgpMdOJlUne3Uf9cA8pww/lQlEHHcdvoofEYSHoAxMT7wwSut8VdcQKBgQCdaFrfmHtN4AOovtauy3AbdfhhkoyCzN6g/sTDyI4CbLIbMIfqlXTG/RaJYCLVevnmSGCryflDQT69JicSNOVseRZEHli3Qr3G1sS2zU495ZlQGFe6DZomCkw3RxJcX5z25rvvcW3ECDRGpEG17SvMxXWwpD2+0WQL87wEnuwcjwKBgGyak96/SZC6ad3mqNaIftDtxJzAtH4kLwee3y+nzWQqwCEnncwwS+wF8GA2TMXWQmiy/VwL/IrrBmeM7ZXuqx7vraPmbsb++UJjRUFl5JoxMJsSnjyVDz9NZSMlB1F2WnK1q6fs0A+WQ095cvHOyFuzgbggfuR7L8tHdKesiZqhAoGAR4OU3cc6JhxjrTPe95Un/uHvEe1x9y866mw1WznwAvv9Q0seRR7X6lwr9AgAa3sutEgn24SswbiP14HQ+H2dylWNHy+mYMRq0j7bKq5GIOsCZ5hXqwjpAuVk0SxyFBPAjZAwzE19cDXGAl44GH6DisofeTx1bQ9W4/M9dd/6J9MCgYBzW54BbochobX23cFy6QTOQ1zEUGVaabC4rx8/2M9qbORjVWKIcNOLNErm/BmIXkwU/7dPGdkL98poIvYP172obCHdR/vWNEfA9SzTFO2Dkgr7zsJcMM0H/DrUWVx0PFJoQX6uPMnkF71jupqbg0uYtzkVfKVBQ2GA294fWHlvew==&quot;);

        //json
        config.setFormat(&quot;json&quot;);
        //支付宝的公钥，不是咱自己的。沙箱应用处获取
        config.setAlipayPublicKey(&quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtovPlNX2W2/vY7e9FCyb7WTeR61VbgScDzDMpRo866u8ucubHgj9HTt4ebsvwsi5d20l1tqT77mEbEwjCqA8CtfeDyATYuHB+P7SWnotjIIXfFfIAgeAqyIl+7TlsBKt13XAVwQh2LqP2xpzqUCHlhJrvQrrWckzliL/SaqfkHbXRPHqN3O4vNORfOyu5FqXxO5oZ8ADebVkouzi6Rv/wMTazERXIwg2YXYjqkOOQzrojKuHUdHDL9vlC3b0ht1z7cUPLdQE86UoOZCj55dLUvjoZsyxKM/tsGjwvmKJGxvUnDDX88KbGexxFpUS8aN2t0OkE2yzGZgbDtAO3pDTuQIDAQAB&quot;);

        //UTF-8
        config.setCharset(&quot;UTF-8&quot;);
        //RSA2
        config.setSignType(&quot;RSA2&quot;);
        try {
            return new DefaultAlipayClient(config);
        } catch (AlipayApiException e) {
            throw new RuntimeException(e);
        }
    }

}
</code></pre>
<h2 id="支付"><a class="header" href="#支付">支付：</a></h2>
<p>建议参考如下文档：
<a href="https://opendocs.alipay.com/open/028r8t?ref=api&amp;scene=22">https://opendocs.alipay.com/open/028r8t?ref=api&amp;scene=22</a><br />
或者如下代码</p>
<pre><code class="language-java">    @GetMapping(&quot;/pay/{id}&quot;)
    public String pay(@PathVariable int id) throws AlipayApiException {
        Pay pay = payService.getById(id);

        AlipayTradePagePayRequest request = new AlipayTradePagePayRequest();
        AlipayTradePagePayModel model = new AlipayTradePagePayModel();
        model.setOutTradeNo(pay.getUuid());
        model.setTotalAmount(pay.getTotal()+&quot;&quot;);
        model.setSubject(&quot;房租&quot;);
        model.setProductCode(&quot;FAST_INSTANT_TRADE_PAY&quot;);//固定写死这个
        request.setBizModel(model);

        request.setReturnUrl(&quot;http://localhost:8081/order&quot;); // 前端跳转地址
        request.setNotifyUrl(&quot;https://6217to9865.goho.co/pay/cj/ali_callback&quot;);  //支付宝通过后端回调我们的地址。
        AlipayTradePagePayResponse response = alipayClient.pageExecute(request);
        return response.getBody();
    }
</code></pre>
<h3 id="打开支付页面"><a class="header" href="#打开支付页面">打开支付页面</a></h3>
<p>在前端页面打开支付页面时，需要在前端el-button的click事件处理中使用类似如下的代码打开</p>
<pre><code class="language-javascript">//order 是要支付的订单
    pay(order) {
      //以下为新开页面打开
      window.open(&quot;http://localhost:8080/order/pay/pay/&quot;+order.id);
      //以下为原页面打开
      //window.location.href=&quot;http://localhost:8080/order/pay/pay/&quot;+order.id
    }
    
</code></pre>
<h2 id="后端支付回调简化实现--内网穿透工具可用时"><a class="header" href="#后端支付回调简化实现--内网穿透工具可用时">后端支付回调（简化实现--内网穿透工具可用时）</a></h2>
<pre><code class="language-java">    @RequestMapping(&quot;/ali_callback&quot;)
    public String callback(String out_trade_no) {  //OutTradeNo  --&gt; out_trade_no
       Pay pay =  payService.getByUUID(out_trade_no);
       pay.setStatus(PayStatus.PAID.name());
       boolean success = payService.updateById(pay);
       // 成功返回 succes  失败 返回 fail
       return success ? &quot;success&quot; : &quot;fail&quot;;
    }
</code></pre>
<h2 id="前端支付回调-简化实现--内网穿透工具不可用时"><a class="header" href="#前端支付回调-简化实现--内网穿透工具不可用时">前端支付回调 （简化实现--内网穿透工具不可用时）</a></h2>
<pre><code class="language-java">    //本实现方式为简化实现方式，仅用于内网穿透不可用时，工作中不可这样使用。
    @GetMapping(&quot;/callback&quot;)
    public void callback(@RequestParam String out_trade_no, HttpServletResponse response) throws IOException {
        QueryWrapper query = new QueryWrapper();
        query.eq(&quot;uuid&quot;, out_trade_no); //根据传入的参数out_trade_no(数据库中的uuid字段)构建查询
        Order order = orderService.getOne(query);
        order.setStatus(&quot;PAID&quot;);    //更新支付单为已支付
        orderService.updateById(order);
        response.sendRedirect(&quot;http://localhost:8081/products&quot;); //跳转页面到目的页面
    }

</code></pre>
<h2 id="支付回调完整实现--实际工作时"><a class="header" href="#支付回调完整实现--实际工作时">支付回调（完整实现--实际工作时）：</a></h2>
<pre><code class="language-java">@RequestMapping(&quot;/ali_callback&quot;)
public Object aliCallback(HttpServletRequest request) {
    Map&lt;String,String&gt; params = combineRequestParams(request);
    try {
        boolean verified = AlipaySignature.rsaCheckV2(params, aliProperties.getPublicKey(), &quot;utf-8&quot;, aliProperties.getSignType());
        if(!verified) {
            return ServerResponse.badRequest().body(&quot;非法请求，验证不通过&quot;);
        }
        String status = params.get(&quot;trade_status&quot;);
        if(&quot;TRADE_SUCCESS&quot;.equals(status)) {
            String out_trade_no = params.get(&quot;out_trade_no&quot;);
            Pay pay = payService.getByUUID(out_trade_no);
            pay.setPayDate(new Date());
            pay.setStatus(PayStatus.PAID.name());
            payService.saveOrUpdate(pay);
            return &quot;success&quot;;
        }
        //确认支付状态是支付成功
        //确认价格一致
        //需要添加更新订单处理。
        return &quot;fail&quot;;
    } catch (AlipayApiException e) {
        log.info(&quot;支付宝回调异常&quot;, e);
        return &quot;fail&quot;;
    }
}

private static Map&lt;String, String&gt; combineRequestParams(HttpServletRequest request) {
    Map&lt;String,String&gt; params = new HashMap&lt;&gt;();
    Map requestParams = request.getParameterMap();
    for(Iterator it = requestParams.keySet().iterator(); it.hasNext();) {
        String name = (String) it.next();
        String[] values = (String[]) requestParams.get(name);
        String valueStr = &quot;&quot;;
        for(int i=0; i&lt;values.length; i++) {
            valueStr = i==(values.length-1) ? valueStr+values[i] : valueStr+values[i]+&quot;,&quot;;
        }
        params.put(name, valueStr);
    }
    params.remove(&quot;sign_type&quot;);
    return params;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="支付宝支付下"><a class="header" href="#支付宝支付下">支付宝支付（下）</a></h1>
<h2 id="扫单"><a class="header" href="#扫单">扫单：</a></h2>
<pre><code>定时查询未支付单，进行处理：
</code></pre>
<ol>
<li>已支付更新状态。</li>
<li>未支付视情况通知支付。</li>
</ol>
<h3 id="定时任务实现"><a class="header" href="#定时任务实现">定时任务实现：</a></h3>
<ol>
<li>在入口类添加注解：</li>
</ol>
<pre><code class="language-java">   @EnableScheduling   
</code></pre>
<ol>
<li>在要执行的方法上添加</li>
</ol>
<pre><code class="language-java">@Scheduled(cron = &quot;0 * * * * ? &quot;)
// 秒 分 时 日 月 周
</code></pre>
<ol>
<li>* 表示所有值。 例如:在分的字段上设置 *,表示每一分钟都会触发。</li>
<li>? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每
月的 10 号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为”?” 具体
设置为 0 0 0 10 * ?</li>
<li>- 表示区间。例如 在小时上设置 “10-12”,表示 10,11,12 点都会触发。</li>
<li>, 表示指定多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五
触发</li>
<li>/ 用于递增触发。如在秒上面设置”5/15” 表示从 5 秒开始，每增 15 秒触发
(5,20,35,50)。 在日字段上设置’1/3’所示每月 1 号开始，每隔三天触发一次。</li>
<li>L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果
是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于”7”或”SAT”。如果在”L”
前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示“本
月最后一个星期五”</li>
<li>W 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上置”15W”，表示
离每月 15 号最近的那个工作日触发。如果 15 号正好是周六，则找最近的周五(14 号)触
发, 如果 15 号是周未，则找最近的下周一(16 号)触发.如果 15 号正好在工作日(周一至周
五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月 1 号往后最近的工作日触发。
如果 1 号正是周六，则将在 3 号下周一触发。(注，”W”前只能设置具体的数字,不允许区
间”-“)。</li>
<li># 序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周
六.注意如果指定”#5”,正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再
合适不过了) ；小提示：’L’和 ‘W’可以一组合使用。如果在日字段上设置”LW”,则表示在
本月的最后一个工作日触发；周字段的设置，若使用英文字母是不区分大小写的，即 MON
与 mon 相同。</li>
</ol>
<h2 id="掉单"><a class="header" href="#掉单">掉单：</a></h2>
<p><a href="https://opendocs.alipay.com/open/028woa?ref=api&amp;scene=common">查询订单状态文档及示例</a></p>
<pre><code class="language-java">  @GetMapping(&quot;/query/{id}&quot;)
    public Result&lt;Boolean&gt; query(@PathVariable int id) throws AlipayApiException, JsonProcessingException {
        Pay pay = payService.getById(id);
        AlipayTradeQueryRequest request = new AlipayTradeQueryRequest();
        AlipayTradeQueryModel model = new AlipayTradeQueryModel();
        model.setOutTradeNo(pay.getUuid());
        request.setBizModel(model);
        AlipayTradeQueryResponse response = alipayClient.execute(request);
        System.out.println(response.getBody());
        Map result = objectMapper.readValue(response.getBody(), Map.class);
        result = (Map)result.get(&quot;alipay_trade_query_response&quot;);
        if(&quot;TRADE_SUCCESS&quot;.equals(result.get(&quot;trade_status&quot;))) {
            if(PayStatus.PAID.name().equals(pay.getStatus())) {
                //不做事情
                return Result.ok(true);
            }else {
                pay.setStatus(PayStatus.PAID.name());
                payService.updateById(pay);
                return Result.ok(true);
            }
        }else {
            return Result.ok(false);
        }
        //wqt
    }
</code></pre>
<h2 id="退款"><a class="header" href="#退款">退款：</a></h2>
<p><a href="https://opendocs.alipay.com/open/028sm9?ref=api">退款api文档及示例</a></p>
<pre><code class="language-java">public boolean refund(int orderId, BigDecimal amount) throws AlipayApiException {
    AlipayTradeRefundRequest request = new AlipayTradeRefundRequest();
    AlipayTradeRefundModel model = new AlipayTradeRefundModel();
    model.setOutTradeNo(String.valueOf(orderId));
    model.setRefundAmount(amount.toPlainString());
    request.setBizModel(model);
    AlipayTradeRefundResponse response = alipayClient.execute(request);
    return response.isSuccess();
}
</code></pre>
<h2 id="退款查询"><a class="header" href="#退款查询">退款查询：</a></h2>
<p><a href="https://opendocs.alipay.com/open/028sma?ref=api">退款查询文档及示例</a></p>
<pre><code class="language-java">public boolean checkRefund(int id) {
    Pay pay = payService.getById(id);
    AlipayTradeFastpayRefundQueryRequest request = new AlipayTradeFastpayRefundQueryRequest();
    AlipayTradeFastpayRefundQueryModel model = new AlipayTradeFastpayRefundQueryModel();
    model.setOutRequestNo(pay.getUuid());
    request.setBizModel(model);
    AlipayTradeFastpayRefundQueryResponse response = alipayClient.execute(request);
    .....
}

</code></pre>
<h2 id="下载支付单"><a class="header" href="#下载支付单">下载支付单：</a></h2>
<p><a href="https://opendocs.alipay.com/open/028woc?ref=api">查询对账单文档及示例</a></p>
<pre><code class="language-java">public String billDownload(String date) throws AlipayApiException {
    AlipayDataDataserviceBillDownloadurlQueryRequest request = new AlipayDataDataserviceBillDownloadurlQueryRequest();
    AlipayDataDataserviceBillDownloadurlQueryModel model = new AlipayDataDataserviceBillDownloadurlQueryModel();
    model.setBillType(&quot;trade&quot;);
    model.setBillDate(date);
    request.setBizModel(model);
    //String content = &quot;{\&quot;bill_type\&quot;:\&quot;trade\&quot; , \&quot;bill_date\&quot;:\&quot;&quot;+date+&quot;\&quot;}&quot;;
    //System.out.println(content);
    //request.setBizContent(content);
    AlipayDataDataserviceBillDownloadurlQueryResponse response = alipayClient.execute(request);
    System.out.println(response.getBody());
    String url = response.getBillDownloadUrl();
    return url;
}
</code></pre>
<h2 id="功能汇总"><a class="header" href="#功能汇总">功能汇总</a></h2>
<p>定义工具类，完成支付所有功能。（不包含支付后回调）</p>
<pre><code class="language-java">

public class PayUtils {

    public static String pay(String out_trade_no, String price, String name, String returnUrl, String notifyUrl) throws AlipayApiException {
        AlipayTradePagePayRequest request = new AlipayTradePagePayRequest();
        AlipayTradePagePayModel model = new AlipayTradePagePayModel();
        model.setOutTradeNo(out_trade_no);
        model.setTotalAmount(price);
        model.setSubject(name);
        model.setProductCode(&quot;FAST_INSTANT_TRADE_PAY&quot;);
        request.setBizModel(model);

        request.setReturnUrl(returnUrl);
        request.setNotifyUrl(notifyUrl);
        AlipayTradePagePayResponse response = alipayClient().pageExecute(request);
        return response.getBody();
    }

    public static boolean check(String out_trade_no) throws AlipayApiException {
        AlipayTradeQueryRequest request = new AlipayTradeQueryRequest();
        AlipayTradeQueryModel model = new AlipayTradeQueryModel();
        model.setOutTradeNo(out_trade_no);
        request.setBizModel(model);
        AlipayTradeQueryResponse response = alipayClient().execute(request);
        return response.isSuccess();
    }

    public static boolean refund(String out_trade_no, BigDecimal amount) throws AlipayApiException {
        AlipayTradeRefundRequest request = new AlipayTradeRefundRequest();
        AlipayTradeRefundModel model = new AlipayTradeRefundModel();
        model.setOutTradeNo(out_trade_no);
        model.setRefundAmount(amount.toPlainString());
        request.setBizModel(model);
        AlipayTradeRefundResponse response = alipayClient().execute(request);
        return response.isSuccess();
    }


    public static String checkRefund(String out_trade_no) throws AlipayApiException {

        AlipayTradeFastpayRefundQueryRequest request = new AlipayTradeFastpayRefundQueryRequest();
        AlipayTradeFastpayRefundQueryModel model = new AlipayTradeFastpayRefundQueryModel();
        model.setOutRequestNo(out_trade_no);
        request.setBizModel(model);
        AlipayTradeFastpayRefundQueryResponse response = alipayClient().execute(request);
        return response.getBody();
    }


    public static String billDownload(String date) throws AlipayApiException {
        AlipayDataDataserviceBillDownloadurlQueryRequest request = new AlipayDataDataserviceBillDownloadurlQueryRequest();
        AlipayDataDataserviceBillDownloadurlQueryModel model = new AlipayDataDataserviceBillDownloadurlQueryModel();
        model.setBillType(&quot;trade&quot;);
        model.setBillDate(date);
        request.setBizModel(model);
        //String content = &quot;{\&quot;bill_type\&quot;:\&quot;trade\&quot; , \&quot;bill_date\&quot;:\&quot;&quot;+date+&quot;\&quot;}&quot;;
        //System.out.println(content);
        //request.setBizContent(content);
        AlipayDataDataserviceBillDownloadurlQueryResponse response = alipayClient().execute(request);
        System.out.println(response.getBody());
        String url = response.getBillDownloadUrl();
        return url;
    }





    public static AlipayClient alipayClient() {
        AlipayConfig config = new AlipayConfig();
        //支付宝测试环境服务器
        config.setServerUrl(&quot;https://openapi.alipaydev.com/gateway.do&quot;);
        //支付宝应用id，在沙箱环境内获取
        config.setAppId(&quot;2016092100560986&quot;);
        //引用私钥，建议使用《支付宝开放平台开发助手》生成，RSA2
        config.setPrivateKey(&quot;MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCLq2XQiqUVyxyO+vT3VIXOhIGWvL1SIs9p28kurzgXzV8JR0X2h+TrSjfyjwYRQH9aV5FFy9NIciA1ce0ZPfxniDt4Bs0pHqLJfkRaUhkotVWn8F6kqqoypy1NfLseDx8GsGXnWVST0wV7xpeOlQM6cflVwYTxx5topyZc5u6NbLssdb/DX1ABjsMsinJQpbgutJFYwy+iWIM7MTSOds4FwZpWdowZ824zfqCMyWibiP1JmguXVcl14eWyOv6LDvDe0niXiF2qMDrTUReVVb+XwEsGb1/cdJT9wU0JDreRH1SSwE6Z+sQdQClfqB/WQJZniveugGf4bXnnZRQfo44fAgMBAAECggEAH7dCHYL+Td6bk5RFQEy/PdA1JSeizh39f4pbOvCrCiymohK/PmZJg2yNG9WCiTReNwOfh3vrdI4F5l0CfDLpOBFlf7H7sJS2Xo7/sormD6pt0v7wXvAqSepQjUH/s6m3X+t6mHhejlri6eKE0+nem8z505FoQQcUsUUTnxEJpq9s1f8SxVF0+6v2va2UqyCbPwKIR0bQLLF7K8a2jl2YBaHRntRi7BCqt4z+IQmHkI6M1zDOysSVbeVX3XlAc54nseorSHAY3ywmjkFSPmBc5MDzNSFgSG2IdHzlTU7R2F4wvExbFGPh64UODzlwcyZFYaTVwUdxhS8JxyXsnHTsQQKBgQDjJs/CMee4AWTN9GNj3XfVW29xjta7XGFJh5BaQRuABpI10nfNyadfwHC7PxjauGqHX2TTpc6991m+kaHOdX5nUyjMOAkhIrmJT1xgPHEjr15Enzp5f8L9NgpMdOJlUne3Uf9cA8pww/lQlEHHcdvoofEYSHoAxMT7wwSut8VdcQKBgQCdaFrfmHtN4AOovtauy3AbdfhhkoyCzN6g/sTDyI4CbLIbMIfqlXTG/RaJYCLVevnmSGCryflDQT69JicSNOVseRZEHli3Qr3G1sS2zU495ZlQGFe6DZomCkw3RxJcX5z25rvvcW3ECDRGpEG17SvMxXWwpD2+0WQL87wEnuwcjwKBgGyak96/SZC6ad3mqNaIftDtxJzAtH4kLwee3y+nzWQqwCEnncwwS+wF8GA2TMXWQmiy/VwL/IrrBmeM7ZXuqx7vraPmbsb++UJjRUFl5JoxMJsSnjyVDz9NZSMlB1F2WnK1q6fs0A+WQ095cvHOyFuzgbggfuR7L8tHdKesiZqhAoGAR4OU3cc6JhxjrTPe95Un/uHvEe1x9y866mw1WznwAvv9Q0seRR7X6lwr9AgAa3sutEgn24SswbiP14HQ+H2dylWNHy+mYMRq0j7bKq5GIOsCZ5hXqwjpAuVk0SxyFBPAjZAwzE19cDXGAl44GH6DisofeTx1bQ9W4/M9dd/6J9MCgYBzW54BbochobX23cFy6QTOQ1zEUGVaabC4rx8/2M9qbORjVWKIcNOLNErm/BmIXkwU/7dPGdkL98poIvYP172obCHdR/vWNEfA9SzTFO2Dkgr7zsJcMM0H/DrUWVx0PFJoQX6uPMnkF71jupqbg0uYtzkVfKVBQ2GA294fWHlvew==&quot;);

        //json
        config.setFormat(&quot;json&quot;);
        //支付宝的公钥，不是咱自己的。沙箱应用处获取
        config.setAlipayPublicKey(&quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtovPlNX2W2/vY7e9FCyb7WTeR61VbgScDzDMpRo866u8ucubHgj9HTt4ebsvwsi5d20l1tqT77mEbEwjCqA8CtfeDyATYuHB+P7SWnotjIIXfFfIAgeAqyIl+7TlsBKt13XAVwQh2LqP2xpzqUCHlhJrvQrrWckzliL/SaqfkHbXRPHqN3O4vNORfOyu5FqXxO5oZ8ADebVkouzi6Rv/wMTazERXIwg2YXYjqkOOQzrojKuHUdHDL9vlC3b0ht1z7cUPLdQE86UoOZCj55dLUvjoZsyxKM/tsGjwvmKJGxvUnDDX88KbGexxFpUS8aN2t0OkE2yzGZgbDtAO3pDTuQIDAQAB&quot;);

        //UTF-8
        config.setCharset(&quot;UTF-8&quot;);
        //RSA2
        config.setSignType(&quot;RSA2&quot;);
        try {
            return new DefaultAlipayClient(config);
        } catch (AlipayApiException e) {
            throw new RuntimeException(e);
        }
    }
}


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="看房"><a class="header" href="#看房">看房</a></h1>
<ul>
<li>
<p>预约看房业务流程</p>
</li>
<li>
<p>预约看房表结构设计</p>
</li>
<li>
<p>预约看房前后端交互实现</p>
</li>
<li>
<p>短信发送</p>
</li>
<li>
<p>环境复杂度</p>
</li>
<li>
<p>短信通知实现</p>
</li>
</ul>
<h2 id="榛子云"><a class="header" href="#榛子云">榛子云</a></h2>
<pre><code>//注册
http://sms_developer.zhenzikj.com/zhenzisms_user/register.html
//登录
http://sms_developer.zhenzikj.com/zhenzisms_user/login.html
//SDK
http://smsow.zhenzikj.com/doc/java_sdk_doc.html
</code></pre>
<h3 id="依赖-1"><a class="header" href="#依赖-1">依赖</a></h3>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.zhenzikj&lt;/groupId&gt;
  &lt;artifactId&gt;zhenzisms&lt;/artifactId&gt;
  &lt;version&gt;2.0.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="配置-1"><a class="header" href="#配置-1">配置</a></h3>
<pre><code class="language-yaml"># 榛子云短信
zzy:
  url: https://sms_developer.zhenzikj.com
  appId: 112605
  secret: 6a987156-398b-4c3c-9d84-ce6b3921bd18

</code></pre>
<h3 id="代码示例-1"><a class="header" href="#代码示例-1">代码示例</a></h3>
<p>简单的发送短信：</p>
<pre><code class="language-java">@GetMapping(&quot;/send_sms&quot;)
public Boolean sendSMS(String phone) throws Exception {
    ZhenziSmsClient client = new ZhenziSmsClient(&quot;https://sms_developer.zhenzikj.com&quot;, &quot;112605&quot;, &quot;6a987156-398b-4c3c-9d84-ce6b3921bd18&quot;);
    Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;();
    params.put(&quot;number&quot;, phone);
    params.put(&quot;templateId&quot;, &quot;10759&quot;);
    String[] templateParams = new String[2];
    templateParams[0] = &quot;3421&quot;;
    templateParams[1] = &quot;5&quot;;
    params.put(&quot;templateParams&quot;, templateParams);
    String result = client.send(params);
    System.out.println(&quot;sms.result = &quot; + result);
    JSON json = JSONUtil.parse(result);
    Integer code = (Integer) json.getByPath(&quot;code&quot;);
    return code==0;
}

</code></pre>
<h2 id="短信发送失败如何处理"><a class="header" href="#短信发送失败如何处理">短信发送失败如何处理</a></h2>
<ol>
<li>
<p>找到错误的原因
一般可以根据api调用的返回判断，一般发生错误的原因：
格式出错
违禁词汇
区域受限
技术层面出错
达到限额
余额不足</p>
</li>
<li>
<p>出现错误怎么解决：<br />
自己找不到原因时要寻找客服人员的帮助
为预防错误，多使用短信模板或固定模板。</p>
</li>
</ol>
<h2 id="短信接口异常如何处理"><a class="header" href="#短信接口异常如何处理">短信接口异常如何处理</a></h2>
<p>可以针对特定异常或异常吗进行重试
记录日志，后期和运营商沟通.</p>
<p>发送短信失败重试，如果三次后仍不成功则打印日志代码示例：</p>
<pre><code class="language-java">@GetMapping(&quot;/send_sms_retry&quot;)
public Result&lt;Boolean&gt; sendSms(String phone) throws Exception {
    Boolean success = retrySend(phone,4);
    return Result.ok(success);
}
private Boolean retrySend(String phone, int num) {
    if(num &lt;=0 ){
        log.error(&quot;发送短信失败，重试后仍旧失败！&quot; + phone);
        return false;
    }
    ZhenziSmsClient client = new ZhenziSmsClient(&quot;https://sms_developer.zhenzikj.com&quot;, &quot;112605&quot;, &quot;6a987156-398b-4c3c-9d84-ce6b3921bd18&quot;);
    Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;();
    params.put(&quot;number&quot;, phone);
    params.put(&quot;templateId&quot;, &quot;10759&quot;);
    String[] templateParams = new String[2];
    templateParams[0] = &quot;3421&quot;;
    templateParams[1] = &quot;5&quot;;
    params.put(&quot;templateParams&quot;, templateParams);
    String result = null;
    try {
        result = client.send(params);
    } catch (Exception e) {
        this.retrySend(phone, num-1);
    }
    System.out.println(&quot;sms.result = &quot; + result);
    JSON json = JSONUtil.parse(result);
    Integer code = (Integer) json.getByPath(&quot;code&quot;);
    if(code != 0){
        this.retrySend(phone, num-1);
    }
    return code==0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rocketmq-基础"><a class="header" href="#rocketmq-基础">RocketMQ 基础</a></h1>
<h2 id="作用-1"><a class="header" href="#作用-1">作用</a></h2>
<p>解耦
异步
削峰</p>
<h2 id="问题"><a class="header" href="#问题">问题</a></h2>
<h3 id="系统可用性降低"><a class="header" href="#系统可用性降低">系统可用性降低</a></h3>
<p>如何保证MQ的高可用</p>
<h3 id="系统复杂度提高"><a class="header" href="#系统复杂度提高">系统复杂度提高</a></h3>
<p>怎么保证消息没有被重复消费？
消费者保证。
防止消息丢失？</p>
<pre><code>生产者 -- 使用事务消息
消费者 -- 使用消息确认
broker -- 早写盘，多备份
</code></pre>
<h2 id="安装-1"><a class="header" href="#安装-1">安装</a></h2>
<h3 id="下载地址"><a class="header" href="#下载地址">下载地址：</a></h3>
<pre><code>https://rocketmq.apache.org/download  
版本选择 4.9.3
</code></pre>
<h3 id="windows版本方法"><a class="header" href="#windows版本方法">windows版本方法：</a></h3>
<h4 id="修改启动脚本"><a class="header" href="#修改启动脚本">修改启动脚本</a></h4>
<p>因为RocketMQ的名称服务器和broker占用内存较大，所以需要将内存调低些。具体是将下面划红线部分替换为：</p>
<pre><code class="language-shell">-server -Xms256m -Xmx256m -Xmn128m
</code></pre>
<ul>
<li>修改 runserver.cmd 
<img src="./imgs/runserver_cmd.png" alt="修改runserver.cmd" /></li>
<li>修改 runbroker.cmd
<img src="./imgs/runbroker_cmd.png" alt="修改runbroker.cmd" /></li>
</ul>
<h4 id="设置环境变量"><a class="header" href="#设置环境变量">设置环境变量：</a></h4>
<p>在系统环境变量中新增</p>
<pre><code class="language-shell">ROCKETMQ_HOME
</code></pre>
<p>指向 RocketMQ的安装目录（<strong>bin的上一层目录</strong>）</p>
<h4 id="启动"><a class="header" href="#启动">启动</a></h4>
<p>启动名称服务器,先跳转到bin目录</p>
<pre><code class="language-shell">    mqnamesrv
</code></pre>
<p>启动broker服务器：</p>
<pre><code class="language-shell">    mqbroker -n localhost:9876
</code></pre>
<p>启动时需要指定名称服务器地址，这个是通过-n来指定的。</p>
<h4 id="测试-2"><a class="header" href="#测试-2">测试</a></h4>
<p>测试是为了确保服务器功能正常，测试方法如下：</p>
<p>在命令窗口中先运行 set NAMESRV_ADDR=localhost:9876 以设置环境变量，
然后运行生产者</p>
<pre><code class="language-shell">    tools.cmd org.apache.rocketmq.example.quickstart.Producer
</code></pre>
<p>和消费者</p>
<pre><code class="language-shell">    tools.cmd org.apache.rocketmq.example.quickstart.Consumer
</code></pre>
<p>看到N多发送消息和接收消息即是正常。</p>
<h3 id="linux版本方法"><a class="header" href="#linux版本方法">linux版本方法：</a></h3>
<h4 id="修改启动脚本-1"><a class="header" href="#修改启动脚本-1">修改启动脚本</a></h4>
<p>将namesrv和broker的内存占用修改为： -server -Xms256m -Xmx256m -Xmn128m</p>
<ul>
<li>
<p>修改nameServer的启动脚本
找到choose_gc_options后，在下面一行做如下修改
vi ./bin/runserver.sh
<img src="./imgs/runserver_sh.png" alt="修改Nameserver脚本" /></p>
</li>
<li>
<p>修改broker的启动脚本
找到如下图
<img src="./imgs/runbroker_sh.png" alt="修改brroker的脚本" />
修改为前面所述的内存大小：<br />
vi ./bin/runbroker.sh
<img src="./imgs/runbroker2_sh.png" alt="修改后的脚本" /></p>
</li>
</ul>
<h4 id="启动-1"><a class="header" href="#启动-1">启动</a></h4>
<p>启动名称服务器</p>
<pre><code class="language-shell">nohup sh bin/mqnamesrv &amp;
</code></pre>
<p>启动broker服务</p>
<pre><code class="language-shell">nohup sh bin/mqbroker -n localhost:9876 &amp;
</code></pre>
<h4 id="测试-3"><a class="header" href="#测试-3">测试</a></h4>
<pre><code class="language-shell">export NAMESRV_ADDR=localhost:9876

./bin/tools.sh org.apache.rocketmq.example.quickstart.Producer  
./bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer s
</code></pre>
<h2 id="开发-1"><a class="header" href="#开发-1">开发</a></h2>
<h3 id="应用引入jar包"><a class="header" href="#应用引入jar包">应用引入jar包：</a></h3>
<pre><code class="language-xml">  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;
    &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.1.0&lt;/version&gt;
  &lt;/dependency&gt;
</code></pre>
<h3 id="配置rocketmq相关信息"><a class="header" href="#配置rocketmq相关信息">配置rocketMQ相关信息</a></h3>
<pre><code class="language-yaml">rocketmq:
  name-server: 127.0.0.1:9876 # rocketMQ 名称服务器
  producer:
    group: test # 发送组
    topic: test-topic  # topic 相当于一个地址
    retry-times-when-send-failed: 5  # 错了以后重试几次
  consumer:
    group: test-consumer  #消费者组
    topic: test-topic   # 消费topic

</code></pre>
<h2 id="消息的发送"><a class="header" href="#消息的发送">消息的发送</a></h2>
<h3 id="同步发送"><a class="header" href="#同步发送">同步发送</a></h3>
<pre><code class="language-java">    @PostMapping(&quot;/send&quot;)
    public Map&lt;String,String&gt; send(@RequestParam String msg) {
        Message&lt;String&gt; message = MessageBuilder.withPayload(msg).build();
        SendResult result = rocketMQTemplate.syncSend(topic,message);
        if(SendStatus.SEND_OK.equals(result.getSendStatus())) {
           return this.of(&quot;status&quot;, &quot;ok&quot;);
        }else {
           return this.of(&quot;status&quot;, &quot;error&quot;);
        }
    }
</code></pre>
<h3 id="异步发送"><a class="header" href="#异步发送">异步发送</a></h3>
<pre><code class="language-java">public void asyncSend(String msg) {
    Message&lt;String&gt; message = MessageBuilder.withPayload(msg).build();
    rocketMQTemplate.asyncSend(topic, message, new SendCallback() {
        @Override
        public void onSuccess(SendResult sendResult) {
            SendStatus sendStatus = sendResult.getSendStatus();
            if(SendStatus.SEND_OK.equals(sendStatus)) {
                System.out.println(&quot;异步发送消息成功&quot;);
            }else {
                System.out.println(&quot;异步发送没有成功。&quot;+sendStatus.name());
            }
        }

        @Override
        public void onException(Throwable throwable) {
            System.out.println(&quot;异步发送消息时发生了错误&quot;);
        }
    });
}
</code></pre>
<h3 id="延迟发送"><a class="header" href="#延迟发送">延迟发送</a></h3>
<pre><code class="language-java">// 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h
    @PostMapping(&quot;/delay_send&quot;)
    public Map&lt;String,String&gt; send(@RequestParam String msg) {
        Message&lt;String&gt; message = MessageBuilder.withPayload(msg).build();
        SendResult result = rocketMQTemplate.syncSend(topic,message,500,5);
        if(SendStatus.SEND_OK.equals(result.getSendStatus())) {
           return this.of(&quot;status&quot;, &quot;ok&quot;);
        }else {
           return this.of(&quot;status&quot;, &quot;error&quot;);
        }
    }
</code></pre>
<h3 id="消息的接收"><a class="header" href="#消息的接收">消息的接收</a></h3>
<pre><code class="language-java">@Service
@RocketMQMessageListener(nameServer = &quot;${rocketmq.name-server}&quot;, topic=&quot;${rocketmq.producer.topic}&quot;, consumerGroup = &quot;${rocketmq.consumer.group}&quot;)
public class MQListener implements RocketMQListener&lt;String&gt; {
    @Override
    public void onMessage(String rocketMqMessage) {
        System.out.println(&quot;=====I have got a message. = &quot; + rocketMqMessage);
    }
}
</code></pre>
<h2 id="确保消息不丢失"><a class="header" href="#确保消息不丢失">确保消息不丢失</a></h2>
<h3 id="1发送事务消息"><a class="header" href="#1发送事务消息">1.发送事务消息</a></h3>
<pre><code class="language-java">    public void sendTransactional(String msg) {
        Message message = MessageBuilder.withPayload(msg).build();
        TransactionSendResult sendResult = rocketMQTemplate.sendMessageInTransaction(topic, message, transactionalListener);

    }
</code></pre>
<pre><code class="language-java">
@Component
@RocketMQTransactionListener
public class TransactionalListener implements RocketMQLocalTransactionListener {

    int times = 0;

    @Autowired
    UserService userService;

    @Override
    public RocketMQLocalTransactionState executeLocalTransaction(Message message, Object o) {
        try{
            userService.deleteUser(6);
            return RocketMQLocalTransactionState.COMMIT;
        }catch (Exception e) {
            return RocketMQLocalTransactionState.ROLLBACK;
        }

       // return RocketMQLocalTransactionState.UNKNOWN;
    }

    @Override
    public RocketMQLocalTransactionState checkLocalTransaction(Message message) {
        times ++;
        System.out.println(&quot;=====第&quot;+times+&quot;次重试。&quot;);
        if(times &gt; 5) {
            System.out.println(&quot;重试5次后终于成功&quot;);
            return RocketMQLocalTransactionState.COMMIT;
        }
        return RocketMQLocalTransactionState.UNKNOWN;
    }
}
</code></pre>
<h3 id="2-确认接收"><a class="header" href="#2-确认接收">2. 确认接收</a></h3>
<pre><code class="language-java">@Component
public class AcknowledgeListener implements MessageListenerOrderly {

    @Value(&quot;${rocketmq.name-server}&quot;)
    private String nameServer;

    @Value(&quot;${rocketmq.producer.topic}&quot;)
    private String topic;

    @Value(&quot;${rocketmq.consumer.group}&quot;)
    private String group;

    private DefaultMQPushConsumer consumer;

    @PostConstruct
    public void init() throws MQClientException {
        consumer =new DefaultMQPushConsumer();
        consumer.setNamesrvAddr(this.nameServer); //设置RocketMQ NameSrv 地址
        consumer.subscribe(topic,&quot;*&quot;);  // 订阅指定topic的内容
        consumer.setConsumerGroup(group);   //设置消费者组
        consumer.setInstanceName(&quot;another&quot;);    //设置实例名，确保不重复
        consumer.registerMessageListener(this); //注册消息监听者，这里注册自己为监听者
        consumer.start();
    }

    @Override
    public ConsumeOrderlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeOrderlyContext consumeOrderlyContext) {
        if(CollectionUtils.isEmpty(list)){
            return ConsumeOrderlyStatus.SUCCESS;
        }
        for(MessageExt ext : list) {
            String msg = new String(ext.getBody());
            processMessage(msg);
        }
        return ConsumeOrderlyStatus.SUCCESS;
    }

    private void processMessage(String msg) {
        System.out.println(&quot;receive &quot;+msg);
    }

}
</code></pre>
<h3 id="启动不起来"><a class="header" href="#启动不起来">启动不起来</a></h3>
<ol>
<li>CLASS_PATH 设置不正确。</li>
</ol>
<h3 id="服务端配置"><a class="header" href="#服务端配置">服务端配置</a></h3>
<ol>
<li>集群配置</li>
<li>主从写同步</li>
<li>磁盘写同步</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rocketmq-集群"><a class="header" href="#rocketmq-集群">RocketMQ 集群</a></h1>
<h2 id="集群部署"><a class="header" href="#集群部署">集群部署：</a></h2>
<p>我们要创建一个2主2从的RocketMQ集群，同时NameServer也创建两个。</p>
<h3 id="windows版本"><a class="header" href="#windows版本">windows版本</a></h3>
<p>创建store根路径</p>
<pre><code>D:\workspaces\rocketmq-4.9.3\data\a
D:\workspaces\rocketmq-4.9.3\data\as
D:\workspaces\rocketmq-4.9.3\data\b
D:\workspaces\rocketmq-4.9.3\data\bs
</code></pre>
<p>修改broker配置文件</p>
<pre><code class="language-properties"># 集群名称
brokerClusterName=DefaultCluster
# broker名称，Master和Slaver要保持统一
brokerName=broker-a
# 0 表示主； 1表示从
brokerId=0
deleteWhen=04
fileReservedTime=48
brokerRole=SYNC_MASTER
flushDiskType=ASYNC_FLUSH
# 创建topic时缺省创建队列数
defaultTopicQueueNums=4
# 自动创建话题，线上关闭
autoCreateTopicEnable=true
autoCreateSubscriptionGroup=true
# IP1 为主用
brokerIP1=127.0.0.1
# IP2 是从找主用
brokerIP2=127.0.0.1
# 端口号，各实例间端口号差距多些更好
listenPort=10931
# 存储主地址
storePathRootDir=D:/workspaces/rocketmq-4.9.3/data/a
# 名称服务器地址
namesrvAddr=127.0.0.1:9876;127.0.0.1:9870

</code></pre>
<p>新建namesrv配置文件 namesrv-1.properties</p>
<pre><code class="language-shell">listenPort=9870
</code></pre>
<p>和 namesrv-2.properties。</p>
<pre><code class="language-shell">listenPort=9876
</code></pre>
<p>启动集群：</p>
<pre><code class="language-shell">start bin\mqnamesrv.cmd -c conf\2m-2s-sync\namesrv-1.properties
start bin\mqnamesrv.cmd -c conf\2m-2s-sync\namesrv-2.properties
start bin\mqbroker.cmd -c conf\2m-2s-sync\broker-a.properties
start bin\mqbroker.cmd -c conf\2m-2s-sync\broker-a-s.properties
start bin\mqbroker.cmd -c conf\2m-2s-sync\broker-b.properties
start bin\mqbroker.cmd -c conf\2m-2s-sync\broker-b-s.properties
</code></pre>
<h3 id="linux版本"><a class="header" href="#linux版本">linux版本：</a></h3>
<p>创建store根路径</p>
<pre><code>/home/nixinfeng/workspace/rocketmq-4.9.3/data/am
/home/nixinfeng/workspace/rocketmq-4.9.3/data/as
/home/nixinfeng/workspace/rocketmq-4.9.3/data/bm
/home/nixinfeng/workspace/rocketmq-4.9.3/data/bs
</code></pre>
<p>创建配置文件：</p>
<pre><code class="language-properties">brokerClusterName=DefaultCluster
brokerName=broker-a
brokerId=0
deleteWhen=04
fileReservedTime=48
brokerRole=SYNC_MASTER
flushDiskType=ASYNC_FLUSH
listenPort=10911
storePathRootDir=/home/nixinfeng/workspace/rocketmq-4.9.3/data/am
namesrvAddr=127.0.0.1:9876

</code></pre>
<p>启动集群：(需要补上namesrv的启动)</p>
<pre><code class="language-shell">nohup bin/mqbroker -c /home/nixinfeng/workspace/rocketmq-4.9.3/conf/2m-2s-sync/broker-a.properties &amp;
nohup bin/mqbroker -c /home/nixinfeng/workspace/rocketmq-4.9.3/conf/2m-2s-sync/broker-a-s.properties &amp;
nohup bin/mqbroker -c /home/nixinfeng/workspace/rocketmq-4.9.3/conf/2m-2s-sync/broker-b.properties &amp;
nohup bin/mqbroker -c /home/nixinfeng/workspace/rocketmq-4.9.3/conf/2m-2s-sync/broker-b-s.properties &amp;
</code></pre>
<h2 id="可能遇到的问题汇总"><a class="header" href="#可能遇到的问题汇总">可能遇到的问题汇总</a></h2>
<ul>
<li>无报错直接退出
<ul>
<li>配置文件路径问题，windows和linux不同。</li>
<li>存储数据的路径权限不够</li>
<li>端口分配，貌似rocket会占用临近的端口号</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xxl-job"><a class="header" href="#xxl-job">xxl-job</a></h1>
<h2 id="下载"><a class="header" href="#下载">下载：</a></h2>
<p><a href="https://gitee.com/xuxueli0323/xxl-job/tags">https://gitee.com/xuxueli0323/xxl-job/tags</a></p>
<p>选择一个双数版本，例如：2.2.0版本。</p>
<ul>
<li>初始化数据库
执行脚本</li>
</ul>
<pre><code class="language-shell">  /xxl-job/doc/db/tables_xxl_job.sql
</code></pre>
<ul>
<li>修改配置文件
进入到xxl-job-admin项目中，修改配置文件(application.properties)中的端口号； 数据库用户名及密码；</li>
<li>编译运行xxl-job-admin</li>
</ul>
<pre><code class="language-shell">  mvn spring-boot:run
</code></pre>
<ul>
<li>xxl-job-admin的缺省密码</li>
</ul>
<pre><code>  admin/123456
</code></pre>
<h2 id="介绍"><a class="header" href="#介绍">介绍：</a></h2>
<p>主要涉及到两个概念</p>
<h3 id="执行器"><a class="header" href="#执行器">执行器</a></h3>
<p>执行器用来执行任务的对象XxlJobSpringExecutor，XxlJobSpringExecutor定义在我们自己的项目中，它的名称用来在xxl-job-admin中标识某个项目。
设置执行器<br />
<img src="./imgs/xxl/xxl-config-1.png" alt="执行器" />
设置任务
<img src="./imgs/xxl/xxl-config-2.png" alt="任务" /></p>
<h3 id="任务"><a class="header" href="#任务">任务</a></h3>
<p>任务是真正执行逻辑的地方，它的运营受到xxl-job-admin的指挥。</p>
<h1 id="在项目中使用"><a class="header" href="#在项目中使用">在项目中使用</a></h1>
<h2 id="引入依赖-1"><a class="header" href="#引入依赖-1">引入依赖</a></h2>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.xuxueli&lt;/groupId&gt;
  &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt;
  &lt;version&gt;2.2.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="添加配置-2"><a class="header" href="#添加配置-2">添加配置</a></h2>
<pre><code class="language-yml">xxl:
  job:
    port: 9998   # xxl-job服务本地监听端口，如果有多个需要使用不同的端口
    accessToken: &quot;&quot;
    admin:
      addresses: http://localhost:9999/xxl-job-admin  # 这里的端口需要跟上文中在xxl-job-admin中配置的端口号一致
    executor: # 执行器，负责和xxl-job-admin通信
      appName: contract # 执行器名称，在xxl-job-admin中定义执行器时需要使用这里定义的名字。
      logpath: D:\tmp\logs # xxl执行器日志存放地址
      logretentiondays: 10 # 日志保留多少天

</code></pre>
<h2 id="初始化"><a class="header" href="#初始化">初始化</a></h2>
<p>在这里使用上面的配合信息，构建一个执行器实例。</p>
<pre><code class="language-java">    @Value(&quot;${xxl.job.admin.addresses}&quot;)
    private String adminAddress;
    @Value(&quot;${xxl.job.accessToken}&quot;)
    private String accessToken;
    @Value(&quot;${xxl.job.executor.appName}&quot;)
    private String appName;
    @Value(&quot;${xxl.job.executor.logpath}&quot;)
    private String logPath;
    @Value(&quot;${xxl.job.executor.logretentiondays}&quot;)
    private int logRententionDays;

    @Value(&quot;${xxl.job.port}&quot;)
    private int port;


    @Bean
    public XxlJobSpringExecutor xxlJobExecutor() {
        XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor();
        xxlJobSpringExecutor.setAdminAddresses(this.adminAddress);
        xxlJobSpringExecutor.setAppname(this.appName);
        xxlJobSpringExecutor.setLogPath(this.logPath);
        xxlJobSpringExecutor.setLogRetentionDays(this.logRententionDays);
        xxlJobSpringExecutor.setPort(port);
        return xxlJobSpringExecutor;
    }
</code></pre>
<h2 id="handler"><a class="header" href="#handler">Handler</a></h2>
<p>定时任务中的任务，由它来完成真正的工作。</p>
<pre><code class="language-java">
    @XxlJob(&quot;payCreatorForOld&quot;)
    public ReturnT&lt;String&gt; updateOldContract(String param) {
        List&lt;Contract&gt; contracts = contractService.getOldContract();
        contracts.stream().forEach(contract -&gt; {
            try {
                log.debug(&quot;===================&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);
                rocketMQService.syncSend(contract);
            } catch (JsonProcessingException e) {
                throw new RuntimeException(e);
            }
        });
        XxlJobLogger.log(&quot;XXl-job for old  &quot;+ param);
        return ReturnT.SUCCESS;
    }

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thread的使用"><a class="header" href="#thread的使用">Thread的使用</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="测试jmeter"><a class="header" href="#测试jmeter">测试JMeter</a></h1>
<h2 id="安装-2"><a class="header" href="#安装-2">安装</a></h2>
<p>下载地址：
<a href="https://jmeter.apache.org/download_jmeter.cgi">https://jmeter.apache.org/download_jmeter.cgi</a></p>
<h2 id="启动-2"><a class="header" href="#启动-2">启动</a></h2>
<p>直接双击bin下的jmeter批处理文件
<img src="./imgs/jmeter/jmeter_start.png" alt="启动" /></p>
<h2 id="使用"><a class="header" href="#使用">使用</a></h2>
<ul>
<li>新建线程组，模拟用户访问，线程数及模拟用户数
<img src="./imgs/jmeter/jmeter_thread_pre.png" alt="创建线程组" /></li>
<li>配置线程组
<img src="./imgs/jmeter/jmeter_thread.png" alt="配置线程组" /></li>
<li>配置http请求
<img src="./imgs/jmeter/jmeter_http_pre.png" alt="配置http请求" /></li>
<li>配置httpGet请求信息
<img src="./imgs/jmeter/jmeter_http_get.png" alt="配置httpGet请求" /></li>
<li>配置httpPost请求
<img src="./imgs/jmeter/jmeter_http_post.png" alt="配置Post请求" /></li>
<li>配置header
<img src="./imgs/jmeter/jmeter_http_post_header_pre.png" alt="配置Header" /></li>
<li>提交json数据时header的内容
<img src="./imgs/jmeter/jmeter_http_post_header.png" alt="配置Content-Type" /></li>
</ul>
<h2 id="查看结果"><a class="header" href="#查看结果">查看结果</a></h2>
<h3 id="结果聚集"><a class="header" href="#结果聚集">结果聚集：</a></h3>
<p>查看整体测试结果
<img src="./imgs/jmeter/jmeter_report_aggregate.png" alt="aggregate" /></p>
<h2 id="结果树"><a class="header" href="#结果树">结果树</a></h2>
<p>查看单个情况
<img src="./imgs/jmeter/jmeter_report_resultTree.png" alt="resultTree" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="合同录入-1"><a class="header" href="#合同录入-1">合同录入</a></h1>
<h2 id="设计表结构"><a class="header" href="#设计表结构">设计表结构</a></h2>
<ol>
<li>01.1 合理设计表结构至少包括合同表，合同付款计划表，采用spring cloud搭建微服务架构至少包括注册中心，配置中心，网关，合同服务。（要求表及字段命名规范，注释清楚，满足三大范式要求，可以适当运用反范式设计）  ??怎么创建付款计划表</li>
<li>02.1 合理设计表结构,用户表，患者表，数据字典表等（要求性别,学历,职业统一用数据字典表处理）</li>
<li>03.1 合理设计表结构,用户表，企业表，数据字典表等（要求所属行业：来自数据字典表）</li>
<li>04.1 合理设计表结构至少包括合同表，合同付款计划表，采用spring cloud搭建微服务架构至少包括注册中心，配置中心，网关，合同服务（要求：Spring Cloud - Eureka注册中心实现高可用功能）。 ??怎么创建付款计划表</li>
</ol>
<h2 id="服务搭建"><a class="header" href="#服务搭建">服务搭建</a></h2>
<ol>
<li>01.2 Spring Cloud - Eureka注册中心实现高可用功能</li>
<li>01.3 Spring Cloud - Gateway网关路由</li>
<li>02.2 搭建spring cloud微服务架构，包括注册中心，配置中心，网关，用户服务，患者服务等.（要求：注册中心实现高可用，服务正常启动）</li>
<li>02.3 Spring Cloud - Gateway网关路由（要求：前端对服务访问均通过gateway访问；gateway网关配置路由；Gateway网关解决跨域问题）</li>
<li>03.2 搭建spring cloud微服务架构，包括注册中心，配置中心，网关，用户服务，企业服务等（注册中心实现高可用，服务正常启动）</li>
<li>03.3 Spring Cloud - Gateway网关路由（前端对服务访问均通过gateway访问；gateway网关配置路由；Gateway网关解决跨域问题）</li>
<li>03.4 服务监考（使用Admin查看用户服务的准实时日志，并演示实时调整日志等级）</li>
<li>04.2 Spring Cloud - Gateway网关路由（前端对服务访问均通过gateway访问；gateway网关配置路由；Gateway网关解决跨域问题）</li>
<li>05.6 Spring Cloud - Eureka注册中心（安装Eureka Server组件，并进行配置；启动Eureka Server并验证服务可用性）</li>
<li>05.8 Spring Cloud - Gateway网关路由（前端对用户中心，费用等系统的访问均通过gateway进行）</li>
<li>06.4 搭建Eureka服务，并将用户，商品等服务注册到Eureka中</li>
<li>06.5 使用Spring Cloud Gateway作为服务网关，所有对接口的调用都需要走网关，正确实现跨域配置</li>
<li>07.1 完成Eureka服务的搭建和配置，并将用户中心、服务管理系统接入Eureka</li>
<li>07.8 搭建网关服务，并合理配置路由，确保用户服务、服务管理服务等</li>
</ol>
<h2 id="链路追踪"><a class="header" href="#链路追踪">链路追踪</a></h2>
<ol>
<li>01.4 使用Zipkin作为链路追踪的框架，将所有的应用都集成到Zipkin上，并演示应用之间的调用链路和延迟时间等信息。</li>
<li>02.4 使用Zipkin作为链路追踪的框架，将所有的应用都集成到Zipkin上，并演示应用之间的调用链路和延迟时间等信息</li>
<li>04.3 使用Zipkin作为链路追踪的框架，将所有的应用都集成到Zipkin上，并演示应用之间的调用链路和延迟时间等信息</li>
<li>06.6 使用Zipkin作为链路追踪的框架，将所有的应用都集成到Zipkin上，并演示应用之间的调用链路和延迟时间等信息</li>
</ol>
<h2 id="合同列表"><a class="header" href="#合同列表">合同列表</a></h2>
<ol>
<li>01.5 正确分页，要求能够查看每个合同的付款计划列表。</li>
<li>02.6 患者列表正确展示(必须包含患者编号)，分页正确</li>
<li>03.6 企业列表页面（列表正确展示(必须包含企业编号)，分页正确）</li>
<li>04.5 合同列表（正确分页；用户登录只能查看自己录入的合同信息，非自己录入的不能查看；要求切换不同用户进行展示）</li>
<li>04.6 合同列表-搜索功能（根据合同编号精确查询；根据租客名称模糊查询；根据签约和到期日期精确查询）</li>
<li>05.1 费用管理 - 列表展示（按照生成日期降序排序；点击某一行可以进入该费用的详情页)</li>
<li>06.1 列表展示 使用Vue和ElementUI实现一个商品列表页面，要求包含商品名称、价格、单位、库存等信息，并支持分页</li>
<li>07.3 实现服务管理中的列表页，包括列表展示、搜索、分页等功能(完成根据服务类型（精确查询）和服务名称（模糊查询）的查询)</li>
<li>08.2 用户可以输入房屋名称进行搜索，后端根据名称过滤查询数据库中的房屋数据，并返回给前端。(缓存搜索列表首页数据，提高页面的响应能力)</li>
<li>10.2 2. 在后端实现分页功能，通过接口参数传递页码和每页显示的数量，后端根据这些参数查询数据库，返回相应的结果给前端。(使用Redis缓存第一页的数据，提升系统性能)</li>
</ol>
<pre><code class="language-java">@GetMapping(&quot;/page/{page}/{size}&quot;)
public Result&lt;IPage&lt;Orders&gt;&gt; page(@PathVariable int page, @PathVariable int size) {
    IPage&lt;Orders&gt; ipage = new Page(page, size);
    if(page == 1) {
        System.out.println(&quot;=========第一页&quot;);
        String key = key(page, size);
        IPage&lt;Orders&gt; orders = (IPage&lt;Orders&gt;)redisTemplate.opsForValue().get(key);
        if(orders == null) {
            System.out.println(&quot;第一页走数据库&quot;);
            ordersService.page(ipage); //从数据库中分页读取数据
            redisTemplate.opsForValue().set(key,ipage,30, TimeUnit.MINUTES);
            return Result.ok(ipage);
        }else {
            System.out.println(&quot;第一页走缓存&quot;);
            return Result.ok(orders);
        }
    }else {
        System.out.println(&quot;其他页走数据库&quot;);
        ordersService.page(ipage);
        return Result.ok(ipage);
    }
}
</code></pre>
<ol start="11">
<li>09.2 提供一个房屋列表页面，前端可以通过API接口获取所有房屋的数据，并实现分页功能。(确保大数量的情况下，分页性能不受影响)</li>
</ol>
<h2 id="格式验证"><a class="header" href="#格式验证">格式验证：</a></h2>
<ol>
<li>01.6 合同录入 -完成页面原型前端校验（签订日期小于结束日期；签订日期小于结束日期）</li>
</ol>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;about&quot;&gt;
    &lt;el-form ref=&quot;form&quot; :model=&quot;contract&quot; :rules=&quot;rules&quot;&gt;
      &lt;el-form-item label=&quot;开始时间&quot; prop=&quot;start&quot;&gt;
        &lt;el-date-picker v-model=&quot;contract.start&quot; type=&quot;date&quot;&gt;&lt;/el-date-picker&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;开始时间&quot; prop=&quot;end&quot;&gt;
        &lt;el-date-picker v-model=&quot;contract.end&quot; type=&quot;date&quot;&gt;&lt;/el-date-picker&gt;
      &lt;/el-form-item&gt;
    &lt;/el-form&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export  default {
  name: &quot;AboutView&quot;,
  data() {
    let validateStart = (rule, value, callback) =&gt; {
      if(this.contract.end == null) {
        callback();
      }
      if(value &gt;= this.contract.end ) {
        callback(new Error(&quot;开始不能大于结束&quot;));
      }else {
        callback();
      }
    };
    let validateEnd = (rule, value, callback) =&gt; {
      if(this.contract.start == null) {
        callback();
      }
      if(value &lt;= this.contract.start) {
        callback(new Error(&quot;结束不能大于开始&quot;));
      }else {
        callback();
      }
    }
    return {
      contract: {
        start: null,
        end: null
      },
      rules: {
        start: [
          {required: true, message: &quot;不能为空&quot;, trigger: 'blur'},
          {validator: validateStart, trigger: 'blur'}
        ],
        end:[
          {required: true, message: &quot;不能为空&quot;, trigger: 'blur'},
          {validator: validateEnd, trigger: 'blur'}
        ]
      },

    }
  }
}
&lt;/script&gt;

</code></pre>
<ol start="2">
<li>01.7 合同录入 -完成页面原型后端业务功能（解决合同编号重复问题；合同业务类型来自redis数据缓存；要考虑表单重复提交的解决方案）</li>
</ol>
<pre><code class="language-java">//1， 从缓存中读取数据
//2, 从cookie中获取用户ID，实现读取当前用户的购物车的逻辑。
@GetMapping(&quot;/list&quot;)
public Result&lt;List&lt;Cart&gt;&gt; list(@CookieValue String token){
    int uid = this.getUidFromToken(token);//从token中获取用户ID
    String key = &quot;&quot;+uid;
    List&lt;Cart&gt; carts = (List&lt;Cart&gt;)redisTemplate.opsForValue().get(key);
    if(carts == null) {//缓存中没有数据，
        System.out.println(&quot;走数据库&quot;);
        carts = cartService.findByUserId(uid);//从数据库中读取
        //将读取的数据放置到redis中，下次请求就可以从redis中读到了。
        redisTemplate.opsForValue().set(key,carts,30, TimeUnit.MINUTES);
    }
    return Result.ok(carts);
}
</code></pre>
<ol start="3">
<li>02.7 患者添加功能（手机号和证件号码(身份证)进行格式校验；年龄必须在1-120岁区间）</li>
</ol>
<pre><code class="language-javascript"> data() {
    let age = (rule,v, callback) =&gt; {
      //使用正则表达式判断是否是合法的身份证
      if(/(^\d{8}(0\d|10|11|12)([0-2]\d|30|31)\d{3}$)|(^\d{6}(18|19|20)\d{2}(0\d|10|11|12)([0-2]\d|30|31)\d{3}(\d|X|x)$)/.test(v)) {
        //获取身份证上的年份
        let year = v.substr(6,4);
        //获取当前的年份
        let thisYear = new Date().getFullYear();
        //获取年龄
        let gap = thisYear - year;
        if(gap &gt;= 1 &amp;&amp; gap &lt;= 120) { //判断年龄在1岁和120岁之间
          callback();
        }else {
          callback(new Error(&quot;年龄必须在1岁和120岁之间&quot;));
        }
      }else {
        callback(new Error(&quot;身份证格式不正确&quot;));
      }
    };
    return {
      rules: {
        birth: [
          {validator: age, trigger: 'blur'}
        ]
      },
      user: {
        mail: &quot;abc@163.com&quot;,
        password: &quot;Aa123456&quot;,
        birth: &quot;510108197911281535&quot;
      }
    }
  }
</code></pre>
<pre><code class="language-java">//后端判断年龄
@PostMapping(&quot;/testAge&quot;)
public Result&lt;Boolean&gt; testAge(@RequestBody Contract contract) {
    int age = IdcardUtil.getAgeByIdCard(contract.getIdcard());
    if(age&gt;=1 &amp;&amp; age&lt;=120) {
        return Result.ok(true);
    }else {
        return Result.ok(false);
    }
}
</code></pre>
<ol start="4">
<li>03.7 企业添加功能-校验功能（手机号进行格式校验；数据字典表中的数据要求采用redis缓存；企业logo只能上传图片功能）</li>
</ol>
<pre><code class="language-javascript">&lt;el-upload
    class=&quot;avatar-uploader&quot;
    action=&quot;https://jsonplaceholder.typicode.com/posts/&quot;
    :show-file-list=&quot;false&quot;
    :on-success=&quot;handleAvatarSuccess&quot;
    :before-upload=&quot;beforeAvatarUpload&quot;&gt; //在上传之前做一些处理
  &lt;img v-if=&quot;imageUrl&quot; :src=&quot;imageUrl&quot; class=&quot;avatar&quot;&gt;
  &lt;i v-else class=&quot;el-icon-plus avatar-uploader-icon&quot;&gt;&lt;/i&gt;
&lt;/el-upload&gt;

methods: {
  beforeAvatarUpload(file) {
    let type = file.type;
    let canUpload =  type === &quot;image/jpeg&quot; || type === &quot;image/png&quot;;
    if(!canUpload) {//如果不是图片则提醒用户
      this.$message.error(&quot;只能上传图片&quot;);
    }
    return canUpload;
  }
}

</code></pre>
<ol start="5">
<li>04.7 合同录入 -完成页面原型前端校验(租约开始日期小于结束日期;租约信息进行非空校验;提交合同录入后端要对用户是否登录进行校验，如果未登录不准录入合同)</li>
</ol>
<pre><code class="language-javascript">// 参见 01.7 解决方案
</code></pre>
<ol>
<li>09.2 完成房屋列表，实现分页和根据名称查找功能</li>
</ol>
<h2 id="用户登录"><a class="header" href="#用户登录">用户登录：</a></h2>
<ol>
<li>02.5 用户登录功能（用户名+密码登录；密码必须采用md5加密技术处理；考虑用户1分钟登录三次不正确进行锁定账号功能）</li>
</ol>
<pre><code class="language-java"> @PostMapping(&quot;/login&quot;)
public Result&lt;String&gt; login(@RequestBody User user, HttpServletResponse response) {
    //因为要判断某用户某分钟输错了几次，所以key要包含用户名称（这里是邮箱）和分钟数
    String key = user.getMail();
    Object obj = redisTemplate.opsForValue().get(key);
    if(obj != null) {
        int times = (int)obj;//检查某用户在这一分钟错误尝试了几次
        if(times &gt;= 3) {// 如果大于三次，则报错
            return Result.err(-3, &quot;错误尝试次数太多&quot;);
        }
    }

    User dbUser = userService.findByMail(user.getMail());
    if(dbUser == null) {
        return Result.err(-1, &quot;用户不存在&quot;);
    }
    if(dbUser.getPassword().equals(encode(dbUser.getSalt(), user.getPassword()))) {
        String token = createToken(dbUser);
        Cookie cookie = new Cookie(&quot;token&quot;, token);
        cookie.setPath(&quot;/&quot;);
        response.addCookie(cookie); //添加cookie
        redisTemplate.opsForValue().set(token, dbUser, 30, TimeUnit.MINUTES);
        return Result.ok(token);
    }else {
        // 密码错误，增加一次
        long result = redisTemplate.opsForValue().increment(key);
        if(result == 1){// 第一次尝试时设置缓存的生命周期为1分钟。
            redisTemplate.expire(key, 1,TimeUnit.MINUTES);
        }
        return Result.err(-2, &quot;密码不正确&quot;);
    }
}
</code></pre>
<ol start="2">
<li>03.5 用户登录功能（用户名+密码登录；密码必须采用md5加密技术处理；考虑用户登录登录成功后采用jwt生成token返回給前端）</li>
<li>04.4 用户登录功能（用户名+密码登录；密码必须采用md5加密技术处理；考虑用户登录登录成功后采用jwt生成token返回給前端）</li>
<li>05.4 用户服务 - 用户登录（使用Vue和Element UI实现一个用户登录页面；前后端分离cookie跨域，页面跨域，登录成功，把认证标识写入cookie中）</li>
</ol>
<pre><code class="language-javascript">login() {
    this.axios.post(&quot;/user/user/login&quot;, this.user)
        .then(res =&gt; {
        console.log(res.data);
        if(res.data.state === 0) {
            document.cookie = &quot;token=&quot;+res.data.data; //注意 token后面的'='是必须的！！！！
            this.$router.push(&quot;/&quot;);
        }
        })
}
</code></pre>
<p>为了保证前端带cookie到后端需要确保main.js中有下面这行代码：</p>
<pre><code class="language-javascript">//它指示了是否该使用类似 cookie、Authorization 标头或者 TLS 客户端证书等凭据进行跨站点访问控制（Acess-Control）请求
axios.defaults.withCredentials=true;
</code></pre>
<ol start="5">
<li>07.2 用户登录功能实现，登录成功写入Cookie(前后端分离cookie跨域，登录成功，把用户信息写入cookie中;将用户信息放入redis中，供后面验证用户是否登录)</li>
<li>08.1 用户登录（前后端分离cookie跨域，页面跨域，登录成功后把必要信息写入cookie中）</li>
<li>09.1 用户登录，后端在登录成功后，将必要的用户信息（如用户ID）写入cookie中，并设置有效期。(设置Cookie跨域，携带Cookie信息到后台)</li>
<li>10.1 用户登录在前后端分离的架构中，使用 JWT（JSON Web Token）实现用户认证和授权。用户登录成功后，后端生成一个 JWT 并返回给前端，前端将 JWT 存储在 Cookie 中(保证JWT和Cookie的过期时间一致，Cookie信息携带到后台进行校验)</li>
</ol>
<h2 id="合同添加"><a class="header" href="#合同添加">合同添加：</a></h2>
<pre><code class="language-java">//引入Hutool依赖，使用其中的雪花算法实现；同时最好数据库中对应字段加上唯一索引。
@GetMapping(&quot;/no&quot;)
public Result&lt;String&gt; no() {
    String no = IdUtil.getSnowflakeNextIdStr();
    return Result.ok(no);
}
</code></pre>
<ol>
<li>02.8 患者添加功能（性别,学历,职业统一来自数据字典表，且采用redis缓存；患者添加功能要考虑防止表单重复提交功能；每个患者要求生成一个唯一的患者编号）</li>
<li>03.8 企业添加功能（添加功能要考虑防止表单重复提交功能；每个企业要求生成一个唯一的患者编号；添加功能考虑用户是否登录进行校验(可以采用网关过滤器实现)）</li>
<li>04.8 合同录入 -完成页面原型后端业务功能(解决合同编号重复问题;要考虑表单重复提交的解决方案;合同录入成功合同录入人员为当前登陆用户;确保金额精度，使用BigDecimal数据类型)</li>
<li>05.2 费用管理 - 添加费用（输入客户名称、生成日期、合同金额等字段，选择费用类型信息，并进行表单验证；
点击添加按钮后，将费用信息提交到后端服务保存，并刷新费用列表页
；解决合同编号重复问题；后台合同金额使用BigDecimal，防止精度丢失）</li>
<li>05.3 费用管理 – 事务 （保存费用时，如果费用类型不存在则添加费用类型后再保存费用，否则直接添加费用即可；添加事务防止费用保存失败，导致数据不完整）</li>
<li>05.5 用户服务 - 用户注册（校验密码规则，必须包含数字、字母，长度大于6位）</li>
</ol>
<pre><code class="language-javascript">/(?=.*\d)(?=.*[a-zA-Z]).{6,}/
</code></pre>
<ol start="7">
<li>06.2 添加商品功能- 要求用户可以输入商品的名称、价格、单位、库存等信息，并能够上传商品图片（确保价格金额精度，使用BigDecimal数据类型；防止保存失败，数据不完整，配置事务；添加商品编号，防止商品编号重复）</li>
<li>06.3 用户服务 - 实现一个简单的用户注册页面，要求用户可以输入用户名、密码等信息，并能够进行表单校验（前后端分离cookie跨域，页面跨域，登录成功，把认证标识写入cookie中）</li>
<li>06.8 创建商品时要防止表单重复提交</li>
<li>07.4 完成服务管理中的创建功能(适当处理防止重复预约;服务编号使用雪花算法防止重复)</li>
<li>08.3 前端发送请求到后端API接口，传递选中的房屋ID等必要信息。  ??</li>
<li>08.4 创建租赁订单页面中，可以修改租赁时间区间，选择时间后即时获得租赁价格（价格计算必须是后端计算后返回给前端，主要使用BigDecimal计算）</li>
<li>08.6 创建租赁订单需要防止用户手误导致创建重复订单(使用Redis实现表单重复提交，代码逻辑正确)</li>
<li>08.7 创建租赁订单时，后端生成唯一的订单号，可以使用UUID或者其他唯一标识符生成算法。</li>
<li>09.3 在房屋列表页面中，提供一个按钮或链接，当用户点击选中某个房屋时，触发生成租赁订单的操作</li>
<li>09.4 后端根据租赁时间区间和房屋信息进行计算，使用BigDecimal进行精确计算，并返回计算后的租赁价格给前端</li>
<li>09.6 后端在接收到创建租赁订单的请求时，先进行重复订单的判断(使用Redis实现表单重复提交，代码逻辑正确)</li>
<li>09.7 在创建租赁订单时，后端生成唯一的订单号，可以使用UUID或者其他唯一标识符生成算法。</li>
<li>10.3 前端选择房屋并提交订单请求，后端接收请求后先进行用户身份验证（通过校验 JWT），确保是登录用户才能创建订单。(JWT工具类校验Token是否合法，然后在创建订单)</li>
<li>10.4 创建租赁订单页面中，可以修改租赁时间区间，选择时间后即时获得租赁价格（价格计算必须是后端计算后返回给前端，主要使用BigDecimal计算）</li>
<li>10.6 当用户提交订单时，后端先查询数据库判断该用户是否已经存在相同的订单。如果有重复订单，则返回错误提示给前端，阻止创建重复订单(使用Redis实现表单重复提交，代码逻辑正确) ??</li>
<li>10.7 在创建租赁订单时，后端可以生成唯一的订单号，确保订单号的唯一性。</li>
</ol>
<h2 id="feign"><a class="header" href="#feign">Feign</a></h2>
<ol>
<li>05.7 Spring Cloud - OpenFeign服务调用（添加费用时，远程（OpenFeign）调用用户中心，确认当前操作人已经登录系统：服务间调用配置Hystrix熔断防止系统雪崩）</li>
<li>07.5 创建服务时需要远程调用（Feign）用户服务，确保只有登录的用户才可以创建服务.</li>
<li>07.6 远程调用实现服务降级，当降级时任何用户都可以创建服务.</li>
<li>08.8 创建租赁订单时需要首先远程调用用户服务，确保只有登录用户才可以创建订单(校验用户状态，避免系统攻击)</li>
<li>09.8 后端通过远程调用用户服务，验证当前用户是否已登录，可以通过检查cookie中的用户信息来进行验证(校验用户状态，避免系统攻击)</li>
<li>10.8 创建租赁订单时，前端携带 JWT 发起请求到用户服务接口，后端通过解析 JWT 获取用户信息，验证用户是否登录。</li>
</ol>
<h2 id="文件上传"><a class="header" href="#文件上传">文件上传</a></h2>
<ol>
<li>06.7    实现一个简单的文件上传功能，要求用户可以选择本地的图片进行上传，并在后台进行保存。（商品图片上传失败，提示“上传失败”）</li>
</ol>
<h2 id="验证身份"><a class="header" href="#验证身份">验证身份：</a></h2>
<ol>
<li>08.5 创建租赁订单中需要填入租赁人的身份证和名称并验证是否真实</li>
<li>09.5 前端发送请求到后端API接口，传递身份证和姓名等参数</li>
<li>10.5 在创建租赁订单页面中，前端通过表单输入租赁人的身份证和名称等信息</li>
</ol>
<pre><code class="language-java">
</code></pre>
<h2 id="admin"><a class="header" href="#admin">Admin</a></h2>
<ol>
<li>07.7 使用Admin查看用户服务的准实时日志，并演示实时调整日志等级.</li>
</ol>
<h2 id="总体其他"><a class="header" href="#总体其他">总体其他：</a></h2>
<ol>
<li>01.8 合同录入 – 事务（合同录入提交后，要求根据分期付款方式完成付款计划的录入；确保付款金额精度，使用BigDecimal数据类型）</li>
</ol>
<h1 id="支付中心"><a class="header" href="#支付中心">支付中心</a></h1>
<h2 id="订单列表"><a class="header" href="#订单列表">订单列表：</a></h2>
<ol>
<li>11.1 页面展示：订单列表页面展示正常，包含金额字段和支付状态，使用element-ui实现</li>
<li>12.1 完成页面开发：包含必要字段：金额字段和支付状态(设计订单表，满足三大范式和业务要求，模拟模拟数据要尽量真实。)</li>
<li>13.1 数据库设计和页面开发：订单信息表结构设计规范，完成服务列表页面开发(设计订单表，满足三大范式和业务要求，模拟模拟数据要尽量真实。)</li>
<li>14.1 支付页面设计符合用户习惯，能快速完成支付操作</li>
<li>15.1 设计订单表，满足三大范式和业务要求，并使用真实数据进行模拟.</li>
<li>16.1 使用Java编程语言生成虚拟订单数据，包括订单号、商品信息、金额等。(设计订单表，满足三大范式和业务要求，模拟模拟数据要尽量真实。)</li>
<li>17.1 可以使用随机数或者测试框架来生成模拟数据，确保数据的真实性和合理性</li>
<li>18.1 使用Java编程语言生成虚拟订单数据，可以使用随机数或测试框架来生成模拟数据(设计订单表，满足三大范式和业务要求，模拟模拟数据要尽量真实)</li>
<li>19.1 设计订单表，模拟数据。（设计订单表，满足三大范式和业务要求，模拟模拟数据要尽量真实）</li>
<li>20.1 设计订单表，模拟数据 （设计订单表，满足三大范式和业务要求，模拟模拟数据要尽量真实。）</li>
</ol>
<h2 id="支付宝集成"><a class="header" href="#支付宝集成">支付宝集成：</a></h2>
<ol>
<li>11.2 支付宝SDK集成：参考官方文档进行集成，支付请求正常，能够跳转到支付宝页面</li>
<li>12.2 支付集成：支付宝支付接口正常集成，在订单页生成合法的支付链接。</li>
<li>13.2 支付集成：能够无缝对接支付宝支付</li>
<li>14.2 支付集成：集成支付宝支付接口，完成支付功能</li>
<li>15.2 Spring Boot集成支付宝，实现支付功能的接入和配置.</li>
<li>16.2 使用支付宝提供的SDK或API，结合Spring Boot框架，实现支付宝支付功能的集成</li>
<li>17.2 配置支付宝的商户信息、密钥等参数，并使用HTTPS协议与支付宝服务器进行交互</li>
<li>18.2 在应用的配置文件中配置支付宝的商户信息、密钥等参数，如商户号、应用ID、私钥等</li>
<li>19.2 在支付请求方法中，调用支付宝SDK或API提供的接口，将订单信息发送给支付宝服务器进行支付</li>
<li>20.2 创建一个支付服务类或控制器，实现支付功能的相关方法，如订单创建、支付请求发送和支付结果查询等</li>
</ol>
<h2 id="回调验签"><a class="header" href="#回调验签">回调验签：</a></h2>
<ol>
<li>11.3 支付宝回调处理：支付回调接口正确验签，对验签通过的请求，及时更新本地订单状态</li>
<li>12.3 回调处理：支付宝回调接口验证测试通过，接收支付宝回调，处理回调成功且正确</li>
<li>13.3 支付回调：回调接口能够接收支付宝的回调，验证签名安全，及时更新支付状态</li>
<li>14.3 支付回调：回调接口接收支付宝支付信息，验证确实为支付宝回调后再更新订单状态，确保支付信息的准确性</li>
<li>15.3 处理支付宝回调验签成功后的后续业务逻辑</li>
<li>16.3 在支付宝支付完成后，支付宝会向指定的回调URL发送支付结果通知(回调接口，完成验签功能，并能够修改业务状态)</li>
<li>17.3 在Spring Boot应用中配置回调URL，并实现接收和解析支付宝回调数据的逻辑</li>
<li>18.3 在接收回调通知的方法中，解析支付宝回调数据，可以使用支付宝SDK或API提供的工具类来解析。</li>
<li>18.4 <em>如果支付成功，更新订单状态为已支付，并记录相关支付信息</em></li>
<li>19.3 获取支付宝回调通知中的签名和其他参数，使用支付宝提供的验签规则对回调数据进行验签</li>
<li>20.3 验签成功后，验证订单信息的正确性，并处理支付结果。可以更新订单状态、生成支付记录、发送通知等操作</li>
<li>20.4 <strong>需要注意处理并发情况下的幂等性问题，确保多次回调不会重复处理订单。</strong></li>
</ol>
<h2 id="掉单处理"><a class="header" href="#掉单处理">掉单处理：</a></h2>
<ol>
<li>11.4 对于‘未支付’订单，系统能够定时进行处理，根据支付宝接口返回的状态更新本地订单状态</li>
<li>12.4 对于未能及时处理回调的订单，能够定时查询支付宝，并根据查询结果更新本地订单状态</li>
<li>15.4 实现调单处理功能，修改订单状态以确保数据准确性和一致性</li>
<li>16.4 检查支付宝回调通知中的支付状态，根据实际需求，处理支付成功或支付失败的订单</li>
<li>17.4 可以更新订单状态、生成支付记录、发送通知等操作，确保订单状态与支付宝同步 ？？</li>
<li>18.4 <em>如果支付成功，更新订单状态为已支付，并记录相关支付信息</em></li>
</ol>
<h2 id="关闭订单"><a class="header" href="#关闭订单">关闭订单：</a></h2>
<ol>
<li>11.5 支付关闭处理：对于超过30分钟没有支付成功的订单，及时关闭</li>
<li>14.5 支付通知：支付成功后，可通过短信或邮件通知用户支付成功，确保用户体验</li>
<li>15.5 使用RocketMQ异步消息通知机制，在订单未支付关闭时发送通知消息。</li>
<li>16.5 根据业务需求设置订单的有效支付时间，超过该时间未支付的订单将自动关闭</li>
<li>18.5 <strong>订单创建时，设置订单的有效支付时间，超过该时间未支付的订单将自动关闭</strong></li>
<li>19.5 当订单被关闭时，将相关订单信息发送到RocketMQ的消息队列中</li>
</ol>
<h2 id="退款-1"><a class="header" href="#退款-1">退款：</a></h2>
<ol>
<li>13.5 退款功能：已支付的订单，完成退款功能，退款成功修改订单状态</li>
</ol>
<h2 id="支付成功通知"><a class="header" href="#支付成功通知">支付成功通知：</a></h2>
<ol>
<li>12.5 支付成功通知：对于成功支付的客户，及时向客户发送支付成功通知。</li>
<li>13.4 支付状态通知：在支付成功的情况下，能够用短信及时通知客户。</li>
<li>14.4 支付通知：支付成功后，可通过短信或邮件通知用户支付成功，确保用户体验</li>
</ol>
<h2 id="其他"><a class="header" href="#其他">其他：</a></h2>
<ol>
<li>17.5 使用RocketMQ作为消息队列，将未支付关闭的订单信息发送到消息队列中</li>
<li>19.4 <strong>如果支付失败，根据需要进行相应的处理操作，如取消订单、释放库存等</strong></li>
<li>20.5 在消费者中实现相应的逻辑，如记录日志、发送提醒等操作，以便及时处理关闭的订单信息 ？？</li>
</ol>
<h1 id="预约看房"><a class="header" href="#预约看房">预约看房</a></h1>
<h2 id="集成rocketmq"><a class="header" href="#集成rocketmq">集成RocketMQ</a></h2>
<ol>
<li>30.1 集成、配置RocketMQ作为支付模块的消息推送机制，确保消息的可靠传递和处理</li>
</ol>
<h2 id="消息消费"><a class="header" href="#消息消费">消息消费</a></h2>
<ol>
<li>30.2 2.	配置RocketMQ的消费者，订阅&quot;payment_topic&quot;主题，并实现相应的业务逻辑来处理支付相关消息</li>
<li>29.2 配置RocketMQ的消费者，订阅&quot;payment_topic&quot;主题，确保消费者能够接收到支付消息，并实现负载均衡和消费者组管理以提高系统的容错性和扩展性  ？？</li>
<li>28.4 将消息的处理过程异步化，并利用RocketMQ的特性实现并行处理，以提高系统的消息处理速度和吞吐量，优化系统性能和资源利用率  ？？？ </li>
<li>22.2 消息消费者从RocketMQ中异步获取消息，并进行处理，例如发送短信、邮件等通知操作。 ？？？</li>
<li>21.2 接收方的消息消费者从RocketMQ中获取消息，之后通过发送短信、邮件通知用户</li>
</ol>
<h2 id="消息发送"><a class="header" href="#消息发送">消息发送</a></h2>
<ol>
<li>30.3 3.	使用RocketMQ的异步发送方式，将支付消息以消息对象的形式发送到&quot;payment_topic&quot;主题，提高系统的并发能力和响应速度</li>
<li>29.1 配置RocketMQ的生产者，设置主题为&quot;payment_topic&quot;，确保消息的可靠传递，并采用可靠性保证机制增加重试次数和错误处理机制</li>
<li>29.4 4.	将用户下单成功、支付成功或取消订单等事件封装成消息对象，并通过异步发送消息的方式减轻直接同步发送短信或邮件对系统性能的影响，提升系统的稳定性和并发能力</li>
<li>28.1 配置系统以确保用户下单成功、支付成功或取消订单等事件能够触发相应的短信或邮件通知，提升用户体验和服务效果 ？？？？</li>
<li>27.1 通过将相关信息封装成消息对象，并利用RocketMQ的生产者将消息发送到指定的消息主题，实现消息的可靠传递和分发</li>
<li>26.1 确保支付模块中用户下单成功、支付成功或取消订单等事件能够触发消息发送，并在消息消费者端正确处理 ？？ 都要发送这些消息吗？</li>
<li>25.1 当用户下单成功、支付成功或取消订单时，调用RocketMQ的生产者发送相应的支付消息到&quot;payment_topic&quot;</li>
<li>25.4 使用RocketMQ的异步发送方式，将消息发送到&quot;payment_topic&quot;主题</li>
<li>24.1 在用户下单或支付时，将通知信息封装成消息并通过RocketMQ发送至中间件</li>
<li>23.1 用户完成购物行为后，将通知信息封装成消息并通过RocketMQ发送至中间件。。</li>
<li>21.1 使用RocketMQ中间件实现业务解耦，发送短信和邮件通知</li>
<li>30.5 添加消息推送的异常处理机制，如消息发送失败时的错误重试机制和错误日志记录，以保证消息的可靠性和系统稳定性</li>
</ol>
<h3 id="消息发送配置"><a class="header" href="#消息发送配置">消息发送配置：</a></h3>
<ol>
<li>22.1 使用RocketMQ进行同步发送消息，并设置合适的重试次数和超时时间，避免网络波动导致消息重复发送</li>
<li></li>
</ol>
<h2 id="防止重复消费"><a class="header" href="#防止重复消费">防止重复消费</a></h2>
<ol>
<li>30.4 为避免重复消费，使用Redis或其他缓存工具记录已经处理过的消息的唯一标识符，以实现幂等性，确保数据处理的准确性和一致性</li>
<li>29.3 为避免重复消费，消息体中添加唯一标识符如订单号或支付流水号，并在消费端进行去重处理，同时使用幂等性机制确保数据处理的准确性和一致性</li>
<li>28.3 利用RocketMQ内置的消息去重机制和消费者端的幂等性处理功能，避免同一条消息被重复消费，确保数据处理的准确性和一致性  ？？内置消息去重</li>
<li>27.3 在消费者处理消息之前，通过检查消息的唯一标识符或状态，确保同一条消息不会被重复消费，保证数据的一致性和正确性。</li>
<li>26.3 利用RocketMQ内置的消息去重机制，结合消费者端的幂等性处理，确保同一条消息不会被重复消费，保证消息的准确性和一致性 ？？ 内置消息去重</li>
<li>25.3 可以使用Redis等缓存工具记录已经处理过的消息的唯一标识符，以防止重复消费</li>
<li>23.3 在消息消费过程中，注意避免重复消费问题，以避免引发业务异常</li>
<li>22.4 为消息添加唯一标识如订单号、支付流水号作为消息ID，确保消息仅被处理一次，避免重复消费</li>
</ol>
<h2 id="防止消息丢失"><a class="header" href="#防止消息丢失">防止消息丢失</a></h2>
<ol>
<li>28.2 正确配置RocketMQ的生产者和消费者实例，以确保消息不会在传递过程中丢失，增强系统的消息可靠性和稳定性  ？？</li>
<li>27.2 RocketMQ采用高可靠的消息传递机制，确保消息能够准确地传递，且不会丢失，提供可靠性保障 ???</li>
<li>26.2 通过将消息发送到RocketMQ消息队列中，确保消息不会丢失，并能够在网络异常或其他问题后恢复正常消费</li>
</ol>
<h2 id="异步"><a class="header" href="#异步">异步？</a></h2>
<ol>
<li>27.4 将短信发送或邮件发送的动作解耦至异步线程中，将发送操作与主线程分离，提高系统的响应速度和并发能力，优化用户体验和系统性能  ？？</li>
<li>26.4 利用RocketMQ的异步发送特性，将短信发送或邮件发送的动作从主线程中解耦，提高系统的响应速度和并发能力，优化用户体验和系统性能</li>
</ol>
<h2 id="消息堆积"><a class="header" href="#消息堆积">消息堆积</a></h2>
<ol>
<li>24.3 消息堆积解决。 增加消息消费线程数：通过增加消息消费线程数，可以提高消息消费速度，减少消息堆积的可能性</li>
<li>22.3 增加消费者数量以提高消息消费速度，降低消息堆积的潜在风险</li>
<li>21.3 通过启用多个消息消费者实例进行并行处理，解决消息积压问题</li>
</ol>
<h2 id="消息补偿"><a class="header" href="#消息补偿">消息补偿</a></h2>
<ol>
<li>24.4 消息补偿。：在消息消费过程中，对于处理失败的消息，进行一定次数的重试操作，并记录错误日志。</li>
<li>23.4 实现消息消费补偿机制，用于在消息消费过程中出现异常时进行重试操作，确保消息的可靠性</li>
<li>21.4 在消息消费过程中出现异常时，通过重试机制保证业务正确性</li>
</ol>
<h2 id="异步2"><a class="header" href="#异步2">异步2</a></h2>
<ol>
<li>24.2 消息接收的设计。 消息消费者从RocketMQ中获取消息，将消息异步处理，例如发送短信、邮件通知用户</li>
<li>23.2 消息消费者从RocketMQ中异步获取消息，并进行相应的处理，如发送短信、邮件通知用户。???</li>
</ol>
<h2 id="消费者集群"><a class="header" href="#消费者集群">消费者集群</a></h2>
<ol>
<li>25.2 将RocketMQ的消费者消费模式设置为集群模式，确保多个消费者能够同时消费消息，提高可靠性  ??</li>
</ol>
<h2 id="其他-1"><a class="header" href="#其他-1">其他</a></h2>
<ol>
<li>21.5 消息推送系统可靠性设计（4分）：包括消息持久化、重试策略和故障恢复机制，确保系统的可靠性  ？？？</li>
<li>22.5	消息可靠性保障（3分）：使用持久化机制存储消息，结合监控手段和故障恢复机制，保证消息推送系统的可靠性</li>
<li>23.5 对于有序消息，考虑实现消息的顺序处理，确保消息按照特定顺序被消费 ???</li>
<li>24.5 建立消息监控机制，实时监测消息堆积情况，并设置相应的报警机制，及时发现和处理异常情况 ？？？</li>
<li>25.5 设置RocketMQ的消息可靠性保障机制，如开启同步刷盘和持久化，确保消息不会丢失。</li>
<li>26.5 配置RocketMQ的消费者端负载均衡策略，确保多个消费者能够均衡消费消息，提高系统的可伸缩性和稳定性</li>
<li>27.5 利用RocketMQ的顺序消息传递特性，确保同一个消息队列中的消息按照发送顺序进行消费，保证消息的顺序性，适用于有序处理的场景</li>
<li>28.5 结合RocketMQ提供的错误消息处理机制和重试策略，及时检测和处理消息处理过程中的异常情况，并进行恰当的重试，以确保系统的稳定运行和消息的可靠发送</li>
<li>29.5 在RocketMQ中配置适当的消息存储策略、消息投递超时时间以及消息重试次数，以确保消息的持久化存储、可靠性投递和容错处理，防止消息丢失或延迟。</li>
</ol>
<h1 id="外卖抢单"><a class="header" href="#外卖抢单">外卖抢单</a></h1>
<h2 id="线程池的使用"><a class="header" href="#线程池的使用">线程池的使用</a></h2>
<ol>
<li>40.1 通过合理的线程池参数配置，控制线程数量，避免资源耗尽和性能下降(请自定义线程池，并合理设置核心参数，以控制线程数量，避免线程过多而导致系统整体性能下降)</li>
<li>39.1 使用线程池管理和调度线程，确保外卖抢单系统能够高效处理大量请求(请自定义线程池，并设置适当的核心参数，避免线程数量过多导致系统整体性能下降)</li>
</ol>
<pre><code class="language-java">//初始化线程池 
@Configuration
public class ThreadPoolConfig {

    @Bean
    public ThreadPoolTaskExecutor executor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setMaxPoolSize(2);//线程池最多有2个线程
        executor.setCorePoolSize(1);//核心线程数为1
        executor.setThreadNamePrefix(&quot;*_*&quot;);//线程名称前缀
        executor.setQueueCapacity(100);//线程池等候队列
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());//拒绝策略
        executor.initialize();//初始化
        return executor;
    }
}
</code></pre>
<ol>
<li>38.1 使用Java多线程技术处理外卖抢单模块的并发请求（请自定义线程池，并设置适当的核心参数，以避免线程数量过多对系统整体性能造成负面影响）</li>
<li>35.1 基于Spring Boot框架构建外卖抢单模块，使用Java多线程技术处理并发请求（自定义线程池，设置核心参数，避免线程过多，影响系统整体性能）</li>
</ol>
<pre><code class="language-java">@RequestMapping(&quot;/process&quot;)
public Result&lt;Boolean&gt; createOrder(Book book) {
    executor.execute(() -&gt; {//使用多线程处理创建订单请求
        Order order = createOrder(book, 1,1);
        orderService.save(order);
    });
    return Result.ok(true);
}
</code></pre>
<ol>
<li>34.2 使用线程池生成外卖订单（使用自定义线程池创建多个线程，并在每个线程中生成多个外卖订单。请设置合理的线程池参数，避免线程数量过多导致系统整体性能下降）</li>
<li>33.3 模拟用户产生大量订单 （使用Java多线程技术实现模拟用户并发产生大量订单。在实现过程中，请自定义线程池，并设置合理的核心参数，以避免线程数量过多导致系统性能下降）</li>
<li>31.2 创建多个线程，并在每个线程中生成多个外卖订单</li>
</ol>
<pre><code class="language-java">    @RequestMapping(&quot;/creat_order&quot;)
    public Result&lt;Boolean&gt; creatOrder() {
        Book book = new Book();
        book.setId(1);
        book.setPrice(BigDecimal.TEN);
        for( int i=0;i&lt;3; i++) {
            executor.execute(() -&gt; {
                while(true) {
                    Order order = createOrder(book,1, 1);
                    orderService.save(order);
                    System.out.println(&quot;create order: &quot; + order.toString());
                    try {
                        Thread.sleep(RandomUtil.randomInt(100,2000));
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }

            });
        }
        return Result.ok(true);
    }
</code></pre>
<h2 id="限流"><a class="header" href="#限流">限流</a></h2>
<pre><code class="language-yaml">
</code></pre>
<ol>
<li>40.2 当达到限流阈值时，返回合适的错误码或页面提示用户稍后再试 (请使用Hystrix或Gateway网关等技术进行服务降级，以避免系统崩溃，并返回适当的错误码或页面提示，告知用户稍后再试) ？？ 怎么实现</li>
<li>39.2 设置适当的限流策略，例如限制API接口每秒请求数或并发请求数(使用Gateway网关对外卖抢单系统进行服务降级，以防止系统崩溃，并确保在高负载情况下系统的正常运行)</li>
<li>38.2 基于网关做限流处理，以防止系统负载过高（通过配置网关进行限流，以确保系统在高负载情况下不会受到过多请求的影响，保持系统的稳定性）</li>
<li>37.2 自定义线程池和设置核心参数，在外卖抢单系统中避免线程过多，影响系统整体性能（通过自定义线程池并设置核心参数来管理外卖抢单系统中的线程，以避免线程过多对系统整体性能造成影响） ？？？</li>
<li>36.2 设置合理的限流策略，如限制API接口每秒请求数或并发请求数 （请描述如何设置合理的限流策略，例如通过Hystrix或Gateway网关进行服务降级，以避免系统崩溃）</li>
<li>35.2 使用分布式限流对外卖抢单接口进行访问频率的限制，防止系统负载过高（使用Hystrix或Gateway网关进行服务降级，避免系统崩溃）</li>
<li>33.2 限制订单服务的访问频率 （为了控制订单服务的访问频率，需要设定最大的访问次数和并发数量。请确保订单服务每分钟最多处理1800次访问请求，并发数量不超过200）</li>
<li>32.4 针对高峰时期流量过大可能引起的系统瘫痪问题实现相应解决方案 ？？？</li>
<li>31.4 针对高峰时期流量过大可能引起的系统瘫痪问题实现相应解决方案</li>
</ol>
<h2 id="超卖"><a class="header" href="#超卖">超卖</a></h2>
<ol>
<li>40.3 根据订单状态和库存信息，使用Redis防止商品超卖 (请根据订单状态和库存信息，使用Redis等缓存技术，实现商品超卖的防止机制，确保每个订单都有足够的库存进行抢购) </li>
<li>39.3 使用Redis的原子操作，实现防止超卖问题的解决方案 (探索并实施基于Redis的原子操作，确保每个订单的抢单过程中不会出现超卖的情况)</li>
<li>38.3 使用Redis缓存热点数据，提高读取速度，减轻数据库压力 （使用Redis作为缓存，存储外卖抢单系统的热点数据，以加快数据的读取速度，减少对数据库的访问，从而减轻数据库的压力）</li>
<li>37.3 当外卖抢单系统达到限流阈值时，如何返回适当的错误码或页面提示用户稍后再试（在外卖抢单系统中如何通过Hystrix或Gateway网关进行服务降级，以避免系统崩溃，并给出相应的错误码或页面提示，在达到限流阈值时引导用户稍后重试）</li>
<li>36.3 在高并发场景下，使用Redis的原子操作（如incr/decr）实现防止超卖问题的解决方案（请详细说明在高并发场景下，如何利用Redis的原子操作（如incr/decr）来有效解决外卖抢单系统中可能出现的超卖问题）</li>
<li>34.3 保证订单抢单的线程安全(为了防止多个用户同时抢购同一个订单，需要实现线程安全机制。请说明你打算如何保证订单抢单的安全性，确保每个订单只能被一个用户抢到) ??? 怎么说明</li>
<li>31.3 考虑多个外卖员同时抢某订单的情况，防止某订单被多人抢到</li>
</ol>
<h2 id="jmeter"><a class="header" href="#jmeter">JMeter</a></h2>
<ol>
<li>40.4 使用JMeter工具，分析测试结果(请使用JMeter工具对系统进行性能测试，分析测试结果，评估系统的吞吐量、并发能力和响应时间等指标，以便进一步优化系统性能)</li>
<li>39.4 评估外卖抢单系统的接口性能和稳定性，包括响应时间、吞吐量和错误率等指标(通过性能测试工具Jmetter，对外卖抢单系统进行接口性能和稳定性测试，分析关键指标包括响应时间、吞吐量和错误率等，以评估系统的性能和稳定性)</li>
<li>38.4 使用JMeter工具创建模拟请求，配置合理的线程数和并发用户数来模拟高峰期访（使用JMeter工具，配置合理的线程数和并发用户数，模拟外卖抢单系统在高峰期的访问情况，以评估系统的性能和可靠性）</li>
<li>37.4 根据订单状态和库存信息，使用Redis维护每个商品的可售数量，并在抢单时进行原子操作，保证库存的准确性（如何利用Redis缓存热点数据，在外卖抢单系统中根据订单状态和库存信息维护每个商品的可售数量，并确保在抢单过程中进行原子操作，以保证库存的准确性）</li>
<li>36.4 使用JMeter测试外卖抢单系统的接口性能 （请介绍如何使用JMeter工具对外卖抢单系统的接口性能进行测试，包括测试的目标、方法和常见指标等） ？？</li>
<li>35.4 使用JMeter工具创建模拟请求，配置合理的线程数和并发用户数来模拟高峰期访问</li>
<li>37.5 使用JMeter工具对外卖抢单系统进行性能分析和优化（请阐述如何使用JMeter工具分析外卖抢单系统的性能，并提出相应的优化方案，例如通过调整线程池大小、数据库连接池参数等来提升系统的处理能力）</li>
</ol>
<h2 id="事务"><a class="header" href="#事务">事务</a></h2>
<ol>
<li>37.1 使用数据库事务机制确保数据的一致性和并发操作的正确性 （利用数据库事务机制来管理外卖抢单系统中的数据操作，以确保数据的一致性和并发操作的正确性）</li>
</ol>
<h2 id="缓存"><a class="header" href="#缓存">缓存</a></h2>
<ol>
<li>35.3 商品加载到Redis缓存中，提高读取速度，减轻数据库压力</li>
<li>32.2 完成产品信息的缓存代码 只需要完成后端代码，缓存信息存放在redis中</li>
</ol>
<h2 id="缓存一致性"><a class="header" href="#缓存一致性">缓存一致性</a></h2>
<ol>
<li>32.3 完成产品更新功能。考虑到产品运行在并发请求中，请实现一种方案，确保缓存和数据库中的数据保持一致</li>
</ol>
<h2 id="订单关闭"><a class="header" href="#订单关闭">订单关闭</a></h2>
<ol>
<li>34.4 编写定时任务自动删除过期订单（编写定时任务，用于自动删除过期的订单。请设定合适的时间间隔，确保系统能够及时清理过期的订单数据，并释放相关资源）</li>
<li>33.1 为了保证订单系统的数据一致性，需要及时关闭未支付订单。请自行设计数据库表结构，满足三大范式要求，并确保数据一致性。订单创建后，如果30分钟内未完成支付，则需要将该订单状态设置为已关闭</li>
</ol>
<h2 id="建表"><a class="header" href="#建表">建表</a></h2>
<ol>
<li>36.1 设计合适的数据库表结构，准备用于保存订单的数据表（设计合适的数据库表结构，满足三大范式要求，并解释如何确保数据的一致性）？？？</li>
<li>34.1 创建外卖订单表（请使用Java代码生成外卖订单表，包含以下字段：订单ID、价格、送餐地址、目的地、创建时间和状态等。你可以自行建表，也可以参考提供的takeaway.sql文件，确保满足三大范式要求并保证数据一致性）</li>
<li>32.1 创建产品表和相应的代码 参考上文中的“product.sql”创建订单表。并生成相应的java代码以实现对该表操作（自行建表，可以参考product.sql，满足三大范式要求，保证数据一致性）</li>
<li>31.1 创建外卖订单表和相应的代码 （5分）参考上文中的“takeaway.sql”创建订单表。并生成相应的java代码以实现对该表操作（自行建表，可以参考takeaway.sql，满足三大范式要求，保证数据一致性）</li>
</ol>
<h2 id="其他-2"><a class="header" href="#其他-2">其他</a></h2>
<ol>
<li>33.4 使用Postman实现创建订单，对订单创建请求进行安全验证 检验是否携带正确的token，只有带有正确token的请求才能创建成功</li>
</ol>
<h2 id="什么鬼"><a class="header" href="#什么鬼">什么鬼？</a></h2>
<ol>
<li>33.5 在使用支付宝接口进行订单处理时，为了确保数据的完整性和安全性，需要进行验签操作。请说明验证签名的步骤，并确保只有通过验签的请求才能被认为是有效的   ？？？说明</li>
<li>34.5 在使用支付宝接口进行订单处理时，为了确保数据的完整性和安全性，需要进行验签操作。请说明验证签名的步骤，并确保只有通过验签的请求才能被认为是有效的</li>
<li>36.5 请说明如何使用JMeter工具对外卖抢单系统的稳定性进行评估，包括模拟高负载、长时间运行和异常情况等测试场景。 ？？？ 异常情况是指？？</li>
<li>38.5 优化外卖抢单系统的性能和用户体验（MQ异步处理订单，以提高外卖抢单系统的性能和用户体验） ？？？</li>
<li>39.5 优化外卖抢单系统的性能和用户体验 (使用Redis缓存热点数据，以提高外卖抢单系统的性能和用户体验)</li>
<li>40.5 如何提高系统性能和用户体验(使用缓存技术或异步处理或负载均衡等手段)</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包含各个项目文档"><a class="header" href="#包含各个项目文档">包含各个项目文档</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="爱家家居商城"><a class="header" href="#爱家家居商城">爱家家居商城</a></h1>
<pre><code>系统需要采用spring cloud微服务架构，包含 注册中心，配置中心，网关等。
</code></pre>
<h2 id="需求描述"><a class="header" href="#需求描述">需求描述</a></h2>
<p>爱家家居是一家对标宜家的家居商家，目前需要开拓网上市场。
作为一个合格的研发者，你需要完成以下功能。</p>
<h2 id="1-登录页面"><a class="header" href="#1-登录页面">1 登录页面</a></h2>
<p>登录时需要有验证码验证。
验证码有效期为3分钟，3分钟内输入有效。
<img src="project/aijia/./imgs/login1.png" alt="登录" /></p>
<h2 id="2-查看家具列表"><a class="header" href="#2-查看家具列表">2 查看家具列表</a></h2>
<pre><code>用户可以查看爱家家居的所有家具，因为预计访问者较多，因此需要对
家具列表添加缓存功能。同时防止缓存被击穿和穿透。
</code></pre>
<p><img src="project/aijia/./imgs/list.png" alt="家居列表" />
注意，以上家具列表中需要自行添加《添加到购物车》按钮，样式参考详情页按钮。
<img src="project/aijia/./imgs/detail.png" alt="家居详情" /></p>
<h2 id="3-加入购物车"><a class="header" href="#3-加入购物车">3 加入购物车</a></h2>
<pre><code>遇到感兴趣的家具可以放入购物车，挑选完毕后可以点击确认购买以生成订单。
</code></pre>
<p><img src="project/aijia/./imgs/gwc.png" alt="购物车" /></p>
<h2 id="4-选择配送地址"><a class="header" href="#4-选择配送地址">4 选择配送地址</a></h2>
<p>在支付前需要用户设置联系手机号和配送地址，需要用三级联动方式实现。</p>
<h2 id="5-支付"><a class="header" href="#5-支付">5 支付</a></h2>
<pre><code>在订单页可以点击支付，支付使用支付宝。
</code></pre>
<h2 id="6-退款"><a class="header" href="#6-退款">6 退款</a></h2>
<pre><code>在订单列表页可以对已付款成功的订单发起退款申请。
</code></pre>
<h2 id="7-定时对账跑批"><a class="header" href="#7-定时对账跑批">7 定时对账跑批</a></h2>
<pre><code>每天上午xx点钟运行支付宝订单对账程序。
</code></pre>
<h2 id="8-配送"><a class="header" href="#8-配送">8 配送</a></h2>
<p>在配送列表页有所有的订单，未配送的有配送按钮，点击后订单状态改为已配送，且同时通过消息队列向用户</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="爱家家居项目"><a class="header" href="#爱家家居项目">爱家家居项目</a></h1>
<h2 id="项目分析"><a class="header" href="#项目分析">项目分析</a></h2>
<h3 id="功能列表"><a class="header" href="#功能列表">功能列表</a></h3>
<ul>
<li>登录</li>
<li>家居列表和详情</li>
<li>加入购物车</li>
<li>配送</li>
<li>支付</li>
<li>退款</li>
<li>定时对账跑批</li>
</ul>
<h3 id="分析"><a class="header" href="#分析">分析</a></h3>
<ul>
<li>用户中心
登录</li>
<li>商品中心
商品列表
商品详情</li>
<li>订单中心
购物车
订单
配送</li>
<li>支付中心
支付
退款
对账跑批</li>
</ul>
<h2 id="数据结构设计"><a class="header" href="#数据结构设计">数据结构设计</a></h2>
<pre><code>user
    id, name, password, created, updated
product
    id name price picture
order
    order
        id userId productId, name, price,address, picture, status, detail, created, updated
    orderItem
        id orderId, productId, price, num
    cart
        id userId productId, price, num
</code></pre>
<h2 id="项目创建"><a class="header" href="#项目创建">项目创建</a></h2>
<h3 id="eureka"><a class="header" href="#eureka">eureka</a></h3>
<p>参考 unit_1.md</p>
<h3 id="config"><a class="header" href="#config">config</a></h3>
<p>参考 ../unit_5.md</p>
<h3 id="gateway"><a class="header" href="#gateway">gateway</a></h3>
<p>参考 ../unit_7.md</p>
<h3 id="service"><a class="header" href="#service">service</a></h3>
<p>参考 resources.md</p>
<h2 id="页面"><a class="header" href="#页面">页面</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spring-cloud-版本"><a class="header" href="#spring-cloud-版本">Spring Cloud 版本</a></h1>
<p>Hoxton.REALEASE</p>
<h2 id="cloud依赖-版本"><a class="header" href="#cloud依赖-版本">cloud依赖 版本：</a></h2>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;

&lt;properties&gt;
    &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;springcloud.version&gt;Hoxton.RELEASE&lt;/springcloud.version&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;
    
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!--监控和管理实例信息--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!--lombok--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
&lt;!--依赖管理--&gt;
&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
            &lt;version&gt;${springcloud.version}&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;!--springboot 插件--&gt;
&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.5.6&lt;/version&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p>web依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h1 id="applicationyml"><a class="header" href="#applicationyml">application.yml</a></h1>
<pre><code class="language-yaml">server:
  #需要改 eureka:8761 gateway:8080 config:8888 user:8083
  port: 8083

spring:
  application:
    #需要改
    name: user

  datasource:
    url: jdbc:mysql://localhost:3306/user?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai
    username: dev
    password: 123456
    type: com.alibaba.druid.pool.DruidDataSource

rocketmq:
  name-server: 127.0.0.1:9876
  producer:
    group: test_group_1
    topic: get_order
  consumer:
    group: consumer_group_1

  redis:
    database: 1
    host: 127.0.0.1
    port: 6379

eureka:
  client:
    register-with-eureka: true # 注册到eureka
    fetch_registry: true #从服务器获取注册信息
    service-url:
      defaultZone: http://localhost:8761/eureka/ # 注册中心地址

logging:
  level:
    root: info
    org:
      springframework:
        web:
          filter:
            CommonsRequestLoggingFilter: debug
</code></pre>
<h2 id="打开请求日志"><a class="header" href="#打开请求日志">打开请求日志</a></h2>
<pre><code class="language-java">    @Bean
    public CommonsRequestLoggingFilter logFilter() {
        CommonsRequestLoggingFilter loggingFilter = new CommonsRequestLoggingFilter();
        loggingFilter.setIncludeQueryString(true);
        loggingFilter.setIncludePayload(true);
        loggingFilter.setMaxPayloadLength(2048);
        return loggingFilter;
    }
</code></pre>
<pre><code class="language-java">org.springframework.web.filter.CommonsRequestLoggingFilter: debug
</code></pre>
<h2 id="通用返回包装"><a class="header" href="#通用返回包装">通用返回包装</a></h2>
<pre><code class="language-java">@Data
public class Result&lt;T&gt; {
    private int state = 0;//ok
    private T data;

    public static &lt;D&gt; Result&lt;D&gt; ok(D d) {
        Result&lt;D&gt; result = new Result&lt;&gt;();
        result.data = d;
        return result;
    }

    public static &lt;D&gt; Result&lt;D&gt; err(int state, D d) {
        Result&lt;D&gt; result = new Result&lt;&gt;();
        result.state = state;
        result.data = d;
        return result;
    }
}

</code></pre>
<h1 id="参考"><a class="header" href="#参考">参考</a></h1>
<h2 id="通用返回包装-1"><a class="header" href="#通用返回包装-1">通用返回包装</a></h2>
<pre><code class="language-java">@Data
public class Result&lt;T&gt; {
    private int state = 0;//ok
    private String message;
    private T data;

    public static &lt;D&gt; Result&lt;D&gt; ok(D d) {
        Result&lt;D&gt; result = new Result&lt;D&gt;();
        result.data = d;
        return result;
    }

    public static &lt;D&gt; Result&lt;D&gt; err(int state, String message) {
        Result&lt;D&gt; result = new Result&lt;D&gt;();
        result.state = state;
        result.message = message;
        return result;
    }
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="相关配置"><a class="header" href="#相关配置">相关配置：</a></h1>
<ul>
<li>在入口类配置mapper扫描</li>
</ul>
<pre><code class="language-java">@MapperScan(&quot;com.eight.user.mapper&quot;)
</code></pre>
<ul>
<li>数据库配置</li>
</ul>
<pre><code class="language-yaml">  datasource:
    url: jdbc:mysql://localhost:3306/user?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai
    username: dev
    password: 123456
    type: com.alibaba.druid.pool.DruidDataSource
</code></pre>
<h1 id="引进jar包"><a class="header" href="#引进jar包">引进jar包</a></h1>
<h2 id="mybatis-plus-版本352"><a class="header" href="#mybatis-plus-版本352">mybatis-plus (版本3.5.2)</a></h2>
<ul>
<li>配置jar包</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;3.5.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- 使用druid连接池，一并引入--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.1.10&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--因为是基于mysql开发，所以一并引入--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>配置分页</li>
</ul>
<pre><code class="language-java">//注意， 这里配置适合mybatis-plus 3.5.2版本
@Configuration
public class MyBatisConfig {

    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    }

}

</code></pre>
<h2 id="数据库"><a class="header" href="#数据库">数据库</a></h2>
<h3 id="创建mysql用户及授权"><a class="header" href="#创建mysql用户及授权">创建mysql用户及授权</a></h3>
<pre><code class="language-sql-mysql">create user 'dev'@'localhost' identified by '123456';
grant all on `order` to 'dev'@'localhost';
grant all on *.* to dev@localhost;
insert into user(name, password, actor) values('admin','$2a$10$XEpgbj4JkA1jtCSQ8HNlXOEk2VOONYL4vmyxDRgkG4NvlqILaHmty','ADMIN');
insert into user(name, password, actor) values('user','$2a$10$XEpgbj4JkA1jtCSQ8HNlXOEk2VOONYL4vmyxDRgkG4NvlqILaHmty','USER');
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redis"><a class="header" href="#redis">Redis</a></h1>
<h2 id="配置-2"><a class="header" href="#配置-2">配置：</a></h2>
<p>两种持久化机制：</p>
<h3 id="rdb"><a class="header" href="#rdb">RDB</a></h3>
<p>RDB （Redis Database）</p>
<pre><code class="language-shell"># save 秒  写请求
save 900 1 #当有一条 Keys 数据被改变时，900 秒刷新到 Disk 一次
save 300 10 #当有 10 条 Keys 数据被改变时，300 秒刷新到 Disk 一次
save 60 10000 #当有 10000 条 Keys 数据被改变时，60 秒刷新到 Disk 一次
</code></pre>
<h3 id="aof"><a class="header" href="#aof">AOF</a></h3>
<p>AOF （Append Only File)</p>
<pre><code class="language-shell">#启用 AOF 持久化方式
appendonly yes
#AOF 文件的名称，默认为 appendonly.aof
appendfilename appendonly.aof 
#每次收到写命令就立即强制写入磁盘，是最有保证的完全的持久化，但速度也是最慢的，一般不推荐使用。
# appendfsync always 
#每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，是受推荐的方式。
appendfsync everysec 
#完全依赖 OS 的写入，一般为 30 秒左右一次，性能最好但是持久化最没有保证，不被推荐。
# appendfsync no
</code></pre>
<h2 id="开发-2"><a class="header" href="#开发-2">开发：</a></h2>
<h3 id="依赖-2"><a class="header" href="#依赖-2">依赖</a></h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="配置-3"><a class="header" href="#配置-3">配置</a></h3>
<pre><code class="language-yaml">spring:
    redis:
    database: 2
    host: 127.0.0.1
    port: 6379
</code></pre>
<h3 id="配置redis序列化方式"><a class="header" href="#配置redis序列化方式">配置redis序列化方式</a></h3>
<pre><code class="language-java">@Bean
public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {
    RedisTemplate&lt;String,Object&gt; template = new RedisTemplate&lt;&gt;();
    template.setConnectionFactory(connectionFactory);
    template.setKeySerializer(RedisSerializer.string());
    template.setValueSerializer(RedisSerializer.json());
    return template;
}
</code></pre>
<h2 id="常见问题"><a class="header" href="#常见问题">常见问题：</a></h2>
<h3 id="redis-链接不上的一个原因"><a class="header" href="#redis-链接不上的一个原因">redis 链接不上的一个原因：</a></h3>
<p>使用缺省的链接库lettuce会有链接不上的情况，出现这种情况时可以改用jedis库，如下：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;
            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;redis.clients&lt;/groupId&gt;
    &lt;artifactId&gt;jedis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="穿透"><a class="header" href="#穿透">穿透</a></h2>
<h3 id="定义"><a class="header" href="#定义">定义</a></h3>
<p>被访问的数据不存在，导致每次请求得数据都不能在缓存中找到，导致请求都要到数据库里。
最终导致数据库压力过大。</p>
<h3 id="解决方案"><a class="header" href="#解决方案">解决方案</a></h3>
<p>每次从数据库中读不到的数据，都在缓存里存放一个空对象。一般要设置一个过期时间，
以防止以后某个时间对应的数据又有了。</p>
<h2 id="击穿"><a class="header" href="#击穿">击穿</a></h2>
<h3 id="定义-1"><a class="header" href="#定义-1">定义</a></h3>
<pre><code>某个非常热点的数据在key失效的瞬间，导致大量的请求直接到了数据库。
</code></pre>
<h3 id="解决方案-1"><a class="header" href="#解决方案-1">解决方案</a></h3>
<ul>
<li>基于redis或zookeeper实现互斥锁</li>
<li>将热点数据设置为永不过期</li>
</ul>
<pre><code class="language-java">public String get(key) {
    String value = redis.get(key);
    if (value == null) { //代表缓存值过期
        //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db
        if (redis.setnx(key_mutex, 1, 3 * 60) == 1) {  //代表设置成功
            value = db.get(key);
            redis.set(key, value, expire_secs);
            redis.del(key_mutex);
        } else {  //这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可
            sleep(50);
            get(key);  //重试
        }
    else {
        return value;      
    }
}
</code></pre>
<h2 id="雪崩"><a class="header" href="#雪崩">雪崩</a></h2>
<h3 id="定义-2"><a class="header" href="#定义-2">定义</a></h3>
<p>雪崩在不同的语境里有不同的内涵，在redis这里的雪崩就是大量热点数据过期，导致大部分缓存数据
在redis层失效，请求直接到数据库层，进而导致数据库压力堵塞甚至宕机。</p>
<h3 id="解决方案-2"><a class="header" href="#解决方案-2">解决方案</a></h3>
<ul>
<li>缓存过期时间分散化</li>
<li>热点数据均匀分布到不同的redis和数据库 （业务不一定允许）</li>
<li>多级缓存 ehcache + redis</li>
</ul>
<h2 id="redis-和-mysql-保持一致"><a class="header" href="#redis-和-mysql-保持一致">redis 和 mysql 保持一致</a></h2>
<pre><code>延时双删
后删除，失败再由MQ的重试机制重复删除。
canal 读取binlog再同步到redis。
</code></pre>
<h1 id="修改密码"><a class="header" href="#修改密码">修改密码</a></h1>
<pre><code class="language-shell">    # 如果是docker，则需要进入docker内部
    docker exec -it myredis redis-cli;
    # 查询当前密码
    config get requirepass
    # 设置密码 your_password 替换成你自己的密码
    config set requirepass your_password
</code></pre>
<h1 id="参考-1"><a class="header" href="#参考-1">参考：</a></h1>
<pre><code>[canal：]( https://zhuanlan.zhihu.com/p/177001630)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="登录与认证"><a class="header" href="#登录与认证">登录与认证</a></h1>
<h2 id=""><a class="header" href="#"></a></h2>
<pre><code class="language-java">private String createToken(User dbUser) {
    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;uid&quot;,dbUser.getId());
    map.put(&quot;name&quot;, dbUser.getName());
    return JWTUtil.createToken(map,&quot;1234&quot;.getBytes());
}
</code></pre>
<h2 id="前端解析jwt"><a class="header" href="#前端解析jwt">前端解析jwt：</a></h2>
<pre><code class="language-javascript">decodeJWT(jwt) {
    return JSON.parse(decodeURIComponent(window.atob(token.split(&quot;.&quot;)[1])))
}
</code></pre>
<p>网关jwt统一检查</p>
<pre><code class="language-java">
@Component
public class JWTFilter implements GlobalFilter, Ordered {
    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        //1. 哪些url需要进行安全检查
        String currentUrl = exchange.getRequest().getPath().value();
        if(!&quot;/user/user/login&quot;.equals(currentUrl)) {
            MultiValueMap&lt;String, HttpCookie&gt; cookies = exchange.getRequest().getCookies();
            if(cookies != null &amp;&amp; cookies.getFirst(&quot;token&quot;) != null) {
                HttpCookie token = cookies.getFirst(&quot;token&quot;);
                String jwt =  token.getValue();
                boolean verify = JWTUtil.verify(jwt, &quot;1234&quot;.getBytes());
                if(!verify) {
                    return needLogin(exchange);
                }

            }else {
                return needLogin(exchange);
            }
        }
        //2, 对于需要安全检查的url进行检验。
        //3,合法通过，不合法拒绝。
        return chain.filter(exchange);
    }

    private Mono&lt;Void&gt; needLogin(ServerWebExchange exchange) {
        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
        return exchange.getResponse().setComplete();
    }

    @Override
    public int getOrder() {
        return 0;
    }
}

</code></pre>
<h1 id="spring-security"><a class="header" href="#spring-security">Spring Security</a></h1>
<h2 id="基础表结构"><a class="header" href="#基础表结构">基础表结构</a></h2>
<pre><code class="language-mysql">create table users(
	username varchar_ignorecase(50) not null primary key,
	password varchar_ignorecase(50) not null,
	enabled boolean not null
);

create table authorities (
	username varchar_ignorecase(50) not null,
	authority varchar_ignorecase(50) not null,
	constraint fk_authorities_users foreign key(username) references users(username)
);
create unique index ix_auth_username on authorities (username,authority);

create table persistent_logins (
	username varchar(64) not null,
	series varchar(64) primary key,
	token varchar(64) not null,
	last_used timestamp not null
);

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前端"><a class="header" href="#前端">前端</a></h1>
<h2 id="工程创建"><a class="header" href="#工程创建">工程创建</a></h2>
<p>vue create project</p>
<h2 id="安装插件"><a class="header" href="#安装插件">安装插件</a></h2>
<pre><code class="language-shell">npm i element-ui -S
npm i axios -S
</code></pre>
<h2 id="编辑mainjs-引入element-ui-axios-配置axios"><a class="header" href="#编辑mainjs-引入element-ui-axios-配置axios">编辑main.js, 引入element-ui, axios; 配置axios，</a></h2>
<pre><code class="language-javascript">import axios from 'axios'
import ElementUI from 'element-ui';
import 'element-ui/lib/theme-chalk/index.css';

Vue.use(ElementUI);
Vue.config.productionTip = false

axios.defaults.baseURL = &quot;http://localhost:8080/&quot;
axios.defaults.withCredentials=true;
Vue.prototype.axios = axios;
</code></pre>
<h2 id="启动服务"><a class="header" href="#启动服务">启动服务</a></h2>
<p>npm run serve -- --port=8081</p>
<h1 id="代码收集"><a class="header" href="#代码收集">代码收集</a></h1>
<h2 id="所有请求都带指定的header"><a class="header" href="#所有请求都带指定的header">所有请求都带指定的header</a></h2>
<p>使用请求拦截器来实现：</p>
<pre><code class="language-javascript">// 请求拦截器
instance.interceptors.request.use(function (config){
  config.headers.token =  &quot;这里放入需要的token&quot;;  //在headers中携带token
  return config
},function (error){
  // 处理请求错误
  return Promise.reject(error)
});
Vue.prototype.axios = instance;

</code></pre>
<h2 id="统一处理axios返回内容"><a class="header" href="#统一处理axios返回内容">统一处理axios返回内容</a></h2>
<pre><code class="language-javascript">//响应拦截器
axios.interceptors.response.use(function (resp){
  return resp;
},function (err){
  console.log(err.request.status);
  if(&quot;401&quot; == err.request.status) {
    router.push(&quot;/login&quot;)
  }
})
</code></pre>
<h2 id="传递参数"><a class="header" href="#传递参数">传递参数</a></h2>
<p>以列表页打开详情页为例，打开详情页时需要传递当前列表的id到详情页。做法如下：</p>
<pre><code class="language-javascript">// 打开/contract页面，同时传递参数ID
    openContract(contract) {
      this.$router.push({path:&quot;/contract&quot;, query:{id:contract.id}})
    }
</code></pre>
<p>获取传递的参数</p>
<pre><code class="language-javascript">  mounted() {
    console.log(&quot;合同ID=&quot;+this.$route.query.id);
  }
</code></pre>
<h2 id="前端安装唯一id工具"><a class="header" href="#前端安装唯一id工具">前端安装唯一ID工具</a></h2>
<pre><code class="language-javascript">npm install nanoid
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="全局异常处理"><a class="header" href="#全局异常处理">全局异常处理</a></h1>
<p>全局异常处理使用两个注解来实现，@ControllerAdvice 和 @ExceptionHandler，如下：</p>
<pre><code class="language-java">//全局异常处理
@RestControllerAdvice
public class ExceptionProcessor {


    @ExceptionHandler({Exception.class})
    public Result&lt;Exception&gt; handleException(Exception e) {
        return Result.ok(e, -1, &quot;通用异常&quot;);
    }

    @ExceptionHandler({BizException.class})
    public Result&lt;BizException&gt; handleException(BizException e) {
        return Result.ok(e,e.getState(),e.getMessage());
    }
}

```java
//自定义异常类，带状态码和错误信息，其中错误信息复用父类的message字段
public class BizException extends  RuntimeException{
    private int state;    
    public int getState() {
        return state;
    }

    public void setState(int state) {
        this.state = state;
    }
    public BizException(int state, String message) {
        super(message);
        this.state = state;
    }
}
</code></pre>
<h2 id="-1"><a class="header" href="#-1"></a></h2>
<h1 id="rocketmq-console"><a class="header" href="#rocketmq-console">rocketmq-console</a></h1>
<p>启动报 java.xml 异常</p>
<pre><code class="language-xml">&lt;dependency&gt;
        &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;
        &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;
        &lt;version&gt;2.3.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt;
        &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt;
        &lt;version&gt;2.3.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt;
        &lt;artifactId&gt;jaxb-core&lt;/artifactId&gt;
        &lt;version&gt;2.3.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.activation&lt;/groupId&gt;
        &lt;artifactId&gt;activation&lt;/artifactId&gt;
        &lt;version&gt;1.1.1&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>
<h1 id="alipay"><a class="header" href="#alipay">alipay</a></h1>
<p>https://openhome.alipay.com/develop/sandbox/app</p>
<p>dermol5132@sandbox.com</p>
<h1 id="mysql"><a class="header" href="#mysql">mysql</a></h1>
<p>修改docker中的数据库时区
docker exec -it mysql sh</p>
<p>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="发送邮件"><a class="header" href="#发送邮件">发送邮件</a></h1>
<h2 id="引进依赖"><a class="header" href="#引进依赖">引进依赖</a></h2>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="添加配置文件"><a class="header" href="#添加配置文件">添加配置文件</a></h2>
<pre><code class="language-yaml">spring:
  mail:
    host: smtp.qq.com
    port: 587
    default-encoding: UTF-8
    username: 1992651344@qq.com
    password: 这里写上你的密码
</code></pre>
<p>QQ邮箱获取密码指南：<br />
QQ邮箱不使用密码，而是用授权码，授权码获取如下所示：
<a href="https://zhidao.baidu.com/question/1608648715083706787.htm">QQ授权码</a></p>
<h2 id="代码实现"><a class="header" href="#代码实现">代码实现</a></h2>
<pre><code class="language-java">
    @Autowired
    JavaMailSender javaMailSender;
    private void sendMail(String to, String subject, String content) {

        SimpleMailMessage simpleMailMessage = new SimpleMailMessage();
        simpleMailMessage.setFrom(&quot;1992651344@qq.com&quot;);
        simpleMailMessage.setTo(to);
        simpleMailMessage.setSubject(subject);
        simpleMailMessage.setText(content);
        simpleMailMessage.setSentDate(new Date());
        javaMailSender.send(simpleMailMessage);
    }
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
