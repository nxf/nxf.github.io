<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>结项 - Spring cloud</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_介绍.html"><strong aria-hidden="true">1.</strong> 简介</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01_Parent.html"><strong aria-hidden="true">1.1.</strong> 父项目搭建</a></li></ol></li><li class="chapter-item expanded "><a href="02_Eureka.html"><strong aria-hidden="true">2.</strong> Eureka</a></li><li class="chapter-item expanded "><a href="03_Ribbon_Hystrix.html"><strong aria-hidden="true">3.</strong> Ribbon&Hystrix</a></li><li class="chapter-item expanded "><a href="04_Feign.html"><strong aria-hidden="true">4.</strong> Feign</a></li><li class="chapter-item expanded "><a href="05_Gateway.html"><strong aria-hidden="true">5.</strong> Gateway</a></li><li class="chapter-item expanded "><a href="06_Config.html"><strong aria-hidden="true">6.</strong> Config</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="06_Config_Rabbit_install.html"><strong aria-hidden="true">6.1.</strong> Rabbit安装</a></li></ol></li><li class="chapter-item expanded "><a href="07_Sleuth.html"><strong aria-hidden="true">7.</strong> Sleuth</a></li><li class="chapter-item expanded "><a href="08_Admin.html"><strong aria-hidden="true">8.</strong> Admin</a></li><li class="chapter-item expanded "><a href="09_合同录入-上.html"><strong aria-hidden="true">9.</strong> 合同录入-上</a></li><li class="chapter-item expanded "><a href="10_合同录入-下.html"><strong aria-hidden="true">10.</strong> 合同录入-下</a></li><li class="chapter-item expanded "><a href="11_支付中心-上.html"><strong aria-hidden="true">11.</strong> 支付中心-上</a></li><li class="chapter-item expanded "><a href="12_支付中心-下.html"><strong aria-hidden="true">12.</strong> 支付中心-下</a></li><li class="chapter-item expanded "><a href="13_预约看房.html"><strong aria-hidden="true">13.</strong> 预约看房</a></li><li class="chapter-item expanded "><a href="14_RocketMQ-上.html"><strong aria-hidden="true">14.</strong> RocketMQ入门</a></li><li class="chapter-item expanded "><a href="15_RocketMQ-下.html"><strong aria-hidden="true">15.</strong> RocketMQ集群</a></li><li class="chapter-item expanded "><a href="16_预约看房消息推送.html"><strong aria-hidden="true">16.</strong> 预约看房消息推送</a></li><li class="chapter-item expanded "><a href="17_外卖抢单-上.html"><strong aria-hidden="true">17.</strong> 外卖抢单-上</a></li><li class="chapter-item expanded "><a href="18_外卖抢单-下.html"><strong aria-hidden="true">18.</strong> 外卖抢单-下</a></li><li class="chapter-item expanded "><a href="19_企业级测试与解决方案.html"><strong aria-hidden="true">19.</strong> 企业级测试与解决方案</a></li><li class="chapter-item expanded "><a href="20_结项.html" class="active"><strong aria-hidden="true">20.</strong> 结项</a></li><li class="chapter-item expanded "><a href="project/index.html"><strong aria-hidden="true">21.</strong> 项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="project/aijia/aijia.html"><strong aria-hidden="true">21.1.</strong> 爱家家具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="project/aijia/analyze.html"><strong aria-hidden="true">21.1.1.</strong> 分析</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="resources.html">基础资源</a></li><li class="chapter-item expanded affix "><a href="mysql.html">mysql</a></li><li class="chapter-item expanded affix "><a href="redis.html">redis</a></li><li class="chapter-item expanded affix "><a href="security.html">security</a></li><li class="chapter-item expanded affix "><a href="front.html">前端</a></li><li class="chapter-item expanded affix "><a href="other.html">其他零碎</a></li><li class="chapter-item expanded affix "><a href="mail.html">邮件</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Spring cloud</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="合同录入"><a class="header" href="#合同录入">合同录入</a></h1>
<h2 id="设计表结构"><a class="header" href="#设计表结构">设计表结构</a></h2>
<ol>
<li>01.1 合理设计表结构至少包括合同表，合同付款计划表，采用spring cloud搭建微服务架构至少包括注册中心，配置中心，网关，合同服务。（要求表及字段命名规范，注释清楚，满足三大范式要求，可以适当运用反范式设计）  ??怎么创建付款计划表</li>
<li>02.1 合理设计表结构,用户表，患者表，数据字典表等（要求性别,学历,职业统一用数据字典表处理）</li>
<li>03.1 合理设计表结构,用户表，企业表，数据字典表等（要求所属行业：来自数据字典表）</li>
<li>04.1 合理设计表结构至少包括合同表，合同付款计划表，采用spring cloud搭建微服务架构至少包括注册中心，配置中心，网关，合同服务（要求：Spring Cloud - Eureka注册中心实现高可用功能）。 ??怎么创建付款计划表</li>
</ol>
<h2 id="服务搭建"><a class="header" href="#服务搭建">服务搭建</a></h2>
<ol>
<li>01.2 Spring Cloud - Eureka注册中心实现高可用功能</li>
<li>01.3 Spring Cloud - Gateway网关路由</li>
<li>02.2 搭建spring cloud微服务架构，包括注册中心，配置中心，网关，用户服务，患者服务等.（要求：注册中心实现高可用，服务正常启动）</li>
<li>02.3 Spring Cloud - Gateway网关路由（要求：前端对服务访问均通过gateway访问；gateway网关配置路由；Gateway网关解决跨域问题）</li>
<li>03.2 搭建spring cloud微服务架构，包括注册中心，配置中心，网关，用户服务，企业服务等（注册中心实现高可用，服务正常启动）</li>
<li>03.3 Spring Cloud - Gateway网关路由（前端对服务访问均通过gateway访问；gateway网关配置路由；Gateway网关解决跨域问题）</li>
<li>03.4 服务监考（使用Admin查看用户服务的准实时日志，并演示实时调整日志等级）</li>
<li>04.2 Spring Cloud - Gateway网关路由（前端对服务访问均通过gateway访问；gateway网关配置路由；Gateway网关解决跨域问题）</li>
<li>05.6 Spring Cloud - Eureka注册中心（安装Eureka Server组件，并进行配置；启动Eureka Server并验证服务可用性）</li>
<li>05.8 Spring Cloud - Gateway网关路由（前端对用户中心，费用等系统的访问均通过gateway进行）</li>
<li>06.4 搭建Eureka服务，并将用户，商品等服务注册到Eureka中</li>
<li>06.5 使用Spring Cloud Gateway作为服务网关，所有对接口的调用都需要走网关，正确实现跨域配置</li>
<li>07.1 完成Eureka服务的搭建和配置，并将用户中心、服务管理系统接入Eureka</li>
<li>07.8 搭建网关服务，并合理配置路由，确保用户服务、服务管理服务等</li>
</ol>
<h2 id="链路追踪"><a class="header" href="#链路追踪">链路追踪</a></h2>
<ol>
<li>01.4 使用Zipkin作为链路追踪的框架，将所有的应用都集成到Zipkin上，并演示应用之间的调用链路和延迟时间等信息。</li>
<li>02.4 使用Zipkin作为链路追踪的框架，将所有的应用都集成到Zipkin上，并演示应用之间的调用链路和延迟时间等信息</li>
<li>04.3 使用Zipkin作为链路追踪的框架，将所有的应用都集成到Zipkin上，并演示应用之间的调用链路和延迟时间等信息</li>
<li>06.6 使用Zipkin作为链路追踪的框架，将所有的应用都集成到Zipkin上，并演示应用之间的调用链路和延迟时间等信息</li>
</ol>
<h2 id="合同列表"><a class="header" href="#合同列表">合同列表</a></h2>
<ol>
<li>01.5 正确分页，要求能够查看每个合同的付款计划列表。</li>
<li>02.6 患者列表正确展示(必须包含患者编号)，分页正确</li>
<li>03.6 企业列表页面（列表正确展示(必须包含企业编号)，分页正确）</li>
<li>04.5 合同列表（正确分页；用户登录只能查看自己录入的合同信息，非自己录入的不能查看；要求切换不同用户进行展示）</li>
<li>04.6 合同列表-搜索功能（根据合同编号精确查询；根据租客名称模糊查询；根据签约和到期日期精确查询）</li>
<li>05.1 费用管理 - 列表展示（按照生成日期降序排序；点击某一行可以进入该费用的详情页)</li>
<li>06.1 列表展示 使用Vue和ElementUI实现一个商品列表页面，要求包含商品名称、价格、单位、库存等信息，并支持分页</li>
<li>07.3 实现服务管理中的列表页，包括列表展示、搜索、分页等功能(完成根据服务类型（精确查询）和服务名称（模糊查询）的查询)</li>
<li>08.2 用户可以输入房屋名称进行搜索，后端根据名称过滤查询数据库中的房屋数据，并返回给前端。(缓存搜索列表首页数据，提高页面的响应能力)</li>
<li>10.2 2. 在后端实现分页功能，通过接口参数传递页码和每页显示的数量，后端根据这些参数查询数据库，返回相应的结果给前端。(使用Redis缓存第一页的数据，提升系统性能)</li>
<li>09.2 提供一个房屋列表页面，前端可以通过API接口获取所有房屋的数据，并实现分页功能。(确保大数量的情况下，分页性能不受影响)</li>
</ol>
<h2 id="格式验证"><a class="header" href="#格式验证">格式验证：</a></h2>
<ol>
<li>01.6 合同录入 -完成页面原型前端校验（签订日期小于结束日期；签订日期小于结束日期）</li>
</ol>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;about&quot;&gt;
    &lt;el-form ref=&quot;form&quot; :model=&quot;contract&quot; :rules=&quot;rules&quot;&gt;
      &lt;el-form-item label=&quot;开始时间&quot; prop=&quot;start&quot;&gt;
        &lt;el-date-picker v-model=&quot;contract.start&quot; type=&quot;date&quot;&gt;&lt;/el-date-picker&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;开始时间&quot; prop=&quot;end&quot;&gt;
        &lt;el-date-picker v-model=&quot;contract.end&quot; type=&quot;date&quot;&gt;&lt;/el-date-picker&gt;
      &lt;/el-form-item&gt;
    &lt;/el-form&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export  default {
  name: &quot;AboutView&quot;,
  data() {
    let validateStart = (rule, value, callback) =&gt; {
      if(this.contract.end == null) {
        callback();
      }
      if(value &gt;= this.contract.end ) {
        callback(new Error(&quot;开始不能大于结束&quot;));
      }else {
        callback();
      }
    };
    let validateEnd = (rule, value, callback) =&gt; {
      if(this.contract.start == null) {
        callback();
      }
      if(value &lt;= this.contract.start) {
        callback(new Error(&quot;结束不能大于开始&quot;));
      }else {
        callback();
      }
    }
    return {
      contract: {
        start: null,
        end: null
      },
      rules: {
        start: [
          {required: true, message: &quot;不能为空&quot;, trigger: 'blur'},
          {validator: validateStart, trigger: 'blur'}
        ],
        end:[
          {required: true, message: &quot;不能为空&quot;, trigger: 'blur'},
          {validator: validateEnd, trigger: 'blur'}
        ]
      },

    }
  }
}
&lt;/script&gt;

</code></pre>
<ol start="2">
<li>01.7 合同录入 -完成页面原型后端业务功能（解决合同编号重复问题；合同业务类型来自redis数据缓存；要考虑表单重复提交的解决方案）</li>
</ol>
<pre><code class="language-java">//1， 从缓存中读取数据
//2, 从cookie中获取用户ID，实现读取当前用户的购物车的逻辑。
@GetMapping(&quot;/list&quot;)
public Result&lt;List&lt;Cart&gt;&gt; list(@CookieValue String token){
    int uid = this.getUidFromToken(token);//从token中获取用户ID
    String key = &quot;&quot;+uid;
    List&lt;Cart&gt; carts = (List&lt;Cart&gt;)redisTemplate.opsForValue().get(key);
    if(carts == null) {//缓存中没有数据，
        System.out.println(&quot;走数据库&quot;);
        carts = cartService.findByUserId(uid);//从数据库中读取
        //将读取的数据放置到redis中，下次请求就可以从redis中读到了。
        redisTemplate.opsForValue().set(key,carts,30, TimeUnit.MINUTES);
    }
    return Result.ok(carts);
}
</code></pre>
<ol start="3">
<li>02.7 患者添加功能（手机号和证件号码(身份证)进行格式校验；年龄必须在1-120岁区间）</li>
</ol>
<pre><code class="language-javascript"> data() {
    let age = (rule,v, callback) =&gt; {
      //使用正则表达式判断是否是合法的身份证
      if(/(^\d{8}(0\d|10|11|12)([0-2]\d|30|31)\d{3}$)|(^\d{6}(18|19|20)\d{2}(0\d|10|11|12)([0-2]\d|30|31)\d{3}(\d|X|x)$)/.test(v)) {
        //获取身份证上的年份
        let year = v.substr(6,4);
        //获取当前的年份
        let thisYear = new Date().getFullYear();
        //获取年龄
        let gap = thisYear - year;
        if(gap &gt;= 1 &amp;&amp; gap &lt;= 120) { //判断年龄在1岁和120岁之间
          callback();
        }else {
          callback(new Error(&quot;年龄必须在1岁和120岁之间&quot;));
        }
      }else {
        callback(new Error(&quot;身份证格式不正确&quot;));
      }
    };
    return {
      rules: {
        birth: [
          {validator: age, trigger: 'blur'}
        ]
      },
      user: {
        mail: &quot;abc@163.com&quot;,
        password: &quot;Aa123456&quot;,
        birth: &quot;510108197911281535&quot;
      }
    }
  }
</code></pre>
<ol start="4">
<li>03.7 企业添加功能-校验功能（手机号进行格式校验；数据字典表中的数据要求采用redis缓存；企业logo只能上传图片功能）</li>
<li>04.7 合同录入 -完成页面原型前端校验(租约开始日期小于结束日期;租约信息进行非空校验;提交合同录入后端要对用户是否登录进行校验，如果未登录不准录入合同)</li>
</ol>
<pre><code class="language-javascript">// 参见 01.7 解决方案
</code></pre>
<ol start="6">
<li>09.2 完成房屋列表，实现分页和根据名称查找功能</li>
</ol>
<h2 id="用户登录"><a class="header" href="#用户登录">用户登录：</a></h2>
<ol>
<li>02.5 用户登录功能（用户名+密码登录；密码必须采用md5加密技术处理；考虑用户1分钟登录三次不正确进行锁定账号功能）</li>
</ol>
<pre><code class="language-java"> @PostMapping(&quot;/login&quot;)
public Result&lt;String&gt; login(@RequestBody User user, HttpServletResponse response) {
    //因为要判断某用户某分钟输错了几次，所以key要包含用户名称（这里是邮箱）和分钟数
    String minute = user.getMail()+DateUtil.minute(new Date());
    Object obj = redisTemplate.opsForValue().get(minute);
    if(obj != null) {
        int times = (int)obj;//检查某用户在这一分钟错误尝试了几次
        if(times &gt;= 3) {// 如果大于三次，则报错
            return Result.err(-3, &quot;错误尝试次数太多&quot;);
        }
    }

    User dbUser = userService.findByMail(user.getMail());
    if(dbUser == null) {
        return Result.err(-1, &quot;用户不存在&quot;);
    }
    if(dbUser.getPassword().equals(encode(dbUser.getSalt(), user.getPassword()))) {
        String token = createToken(dbUser);
        Cookie cookie = new Cookie(&quot;token&quot;, token);
        cookie.setPath(&quot;/&quot;);
        response.addCookie(cookie); //添加cookie
        redisTemplate.opsForValue().set(token, dbUser, 30, TimeUnit.MINUTES);
        return Result.ok(token);
    }else {
        // 密码错误，增加一次
        long result = redisTemplate.opsForValue().increment(minute);
        if(result == 1){// 第一次尝试时设置缓存的生命周期为1分钟。
            redisTemplate.expire(minute, 1,TimeUnit.MINUTES);
        }
        System.out.println(minute+&quot;=======&quot; + result);
        return Result.err(-2, &quot;密码不正确&quot;);
    }
}
</code></pre>
<ol start="2">
<li>03.5 用户登录功能（用户名+密码登录；密码必须采用md5加密技术处理；考虑用户登录登录成功后采用jwt生成token返回給前端）</li>
<li>04.4 用户登录功能（用户名+密码登录；密码必须采用md5加密技术处理；考虑用户登录登录成功后采用jwt生成token返回給前端）</li>
<li>05.4 用户服务 - 用户登录（使用Vue和Element UI实现一个用户登录页面；前后端分离cookie跨域，页面跨域，登录成功，把认证标识写入cookie中）</li>
</ol>
<pre><code class="language-javascript">login() {
    this.axios.post(&quot;/user/user/login&quot;, this.user)
        .then(res =&gt; {
        console.log(res.data);
        if(res.data.state === 0) {
            document.cookie = &quot;token=&quot;+res.data.data; //注意 token后面的'='是必须的！！！！
            this.$router.push(&quot;/&quot;);
        }
        })
}
</code></pre>
<p>为了保证前端带cookie到后端需要确保main.js中有下面这行代码：</p>
<pre><code class="language-javascript">//它指示了是否该使用类似 cookie、Authorization 标头或者 TLS 客户端证书等凭据进行跨站点访问控制（Acess-Control）请求
axios.defaults.withCredentials=true;
</code></pre>
<ol start="5">
<li>07.2 用户登录功能实现，登录成功写入Cookie(前后端分离cookie跨域，登录成功，把用户信息写入cookie中;将用户信息放入redis中，供后面验证用户是否登录)</li>
<li>08.1 用户登录（前后端分离cookie跨域，页面跨域，登录成功后把必要信息写入cookie中）</li>
<li>09.1 用户登录，后端在登录成功后，将必要的用户信息（如用户ID）写入cookie中，并设置有效期。(设置Cookie跨域，携带Cookie信息到后台)</li>
<li>10.1 用户登录在前后端分离的架构中，使用 JWT（JSON Web Token）实现用户认证和授权。用户登录成功后，后端生成一个 JWT 并返回给前端，前端将 JWT 存储在 Cookie 中(保证JWT和Cookie的过期时间一致，Cookie信息携带到后台进行校验)</li>
</ol>
<h2 id="合同添加"><a class="header" href="#合同添加">合同添加：</a></h2>
<pre><code class="language-java">//引入Hutool依赖，使用其中的雪花算法实现；同时最好数据库中对应字段加上唯一索引。
@GetMapping(&quot;/no&quot;)
public Result&lt;String&gt; no() {
    String no = IdUtil.getSnowflakeNextIdStr();
    return Result.ok(no);
}
</code></pre>
<ol>
<li>02.8 患者添加功能（性别,学历,职业统一来自数据字典表，且采用redis缓存；患者添加功能要考虑防止表单重复提交功能；每个患者要求生成一个唯一的患者编号）</li>
<li>03.8 企业添加功能（添加功能要考虑防止表单重复提交功能；每个企业要求生成一个唯一的患者编号；添加功能考虑用户是否登录进行校验(可以采用网关过滤器实现)）</li>
<li>04.8 合同录入 -完成页面原型后端业务功能(解决合同编号重复问题;要考虑表单重复提交的解决方案;合同录入成功合同录入人员为当前登陆用户;确保金额精度，使用BigDecimal数据类型)</li>
<li>05.2 费用管理 - 添加费用（输入客户名称、生成日期、合同金额等字段，选择费用类型信息，并进行表单验证；
点击添加按钮后，将费用信息提交到后端服务保存，并刷新费用列表页
；解决合同编号重复问题；后台合同金额使用BigDecimal，防止精度丢失）</li>
<li>05.3 费用管理 – 事务 （保存费用时，如果费用类型不存在则添加费用类型后再保存费用，否则直接添加费用即可；添加事务防止费用保存失败，导致数据不完整）</li>
<li>05.5 用户服务 - 用户注册（校验密码规则，必须包含数字、字母，长度大于6位）</li>
</ol>
<pre><code class="language-javascript">/(?=.*\d)(?=.*[a-zA-Z]).{6,}/
</code></pre>
<ol start="7">
<li>06.2 添加商品功能- 要求用户可以输入商品的名称、价格、单位、库存等信息，并能够上传商品图片（确保价格金额精度，使用BigDecimal数据类型；防止保存失败，数据不完整，配置事务；添加商品编号，防止商品编号重复）</li>
<li>06.3 用户服务 - 实现一个简单的用户注册页面，要求用户可以输入用户名、密码等信息，并能够进行表单校验（前后端分离cookie跨域，页面跨域，登录成功，把认证标识写入cookie中）</li>
<li>06.8 创建商品时要防止表单重复提交</li>
<li>07.4 完成服务管理中的创建功能(适当处理防止重复预约;服务编号使用雪花算法防止重复)</li>
<li>08.3 前端发送请求到后端API接口，传递选中的房屋ID等必要信息。  ??</li>
<li>08.4 创建租赁订单页面中，可以修改租赁时间区间，选择时间后即时获得租赁价格（价格计算必须是后端计算后返回给前端，主要使用BigDecimal计算）</li>
<li>08.6 创建租赁订单需要防止用户手误导致创建重复订单(使用Redis实现表单重复提交，代码逻辑正确)</li>
<li>08.7 创建租赁订单时，后端生成唯一的订单号，可以使用UUID或者其他唯一标识符生成算法。</li>
<li>09.3 在房屋列表页面中，提供一个按钮或链接，当用户点击选中某个房屋时，触发生成租赁订单的操作</li>
<li>09.4 后端根据租赁时间区间和房屋信息进行计算，使用BigDecimal进行精确计算，并返回计算后的租赁价格给前端</li>
<li>09.6 后端在接收到创建租赁订单的请求时，先进行重复订单的判断(使用Redis实现表单重复提交，代码逻辑正确)</li>
<li>09.7 在创建租赁订单时，后端生成唯一的订单号，可以使用UUID或者其他唯一标识符生成算法。</li>
<li>10.3 前端选择房屋并提交订单请求，后端接收请求后先进行用户身份验证（通过校验 JWT），确保是登录用户才能创建订单。(JWT工具类校验Token是否合法，然后在创建订单)</li>
<li>10.4 创建租赁订单页面中，可以修改租赁时间区间，选择时间后即时获得租赁价格（价格计算必须是后端计算后返回给前端，主要使用BigDecimal计算）</li>
<li>10.6 当用户提交订单时，后端先查询数据库判断该用户是否已经存在相同的订单。如果有重复订单，则返回错误提示给前端，阻止创建重复订单(使用Redis实现表单重复提交，代码逻辑正确) ??</li>
<li>10.7 在创建租赁订单时，后端可以生成唯一的订单号，确保订单号的唯一性。</li>
</ol>
<h2 id="feign"><a class="header" href="#feign">Feign</a></h2>
<ol>
<li>05.7 Spring Cloud - OpenFeign服务调用（添加费用时，远程（OpenFeign）调用用户中心，确认当前操作人已经登录系统：服务间调用配置Hystrix熔断防止系统雪崩）</li>
<li>07.5 创建服务时需要远程调用（Feign）用户服务，确保只有登录的用户才可以创建服务.</li>
<li>07.6 远程调用实现服务降级，当降级时任何用户都可以创建服务.</li>
<li>08.8 创建租赁订单时需要首先远程调用用户服务，确保只有登录用户才可以创建订单(校验用户状态，避免系统攻击)</li>
<li>09.8 后端通过远程调用用户服务，验证当前用户是否已登录，可以通过检查cookie中的用户信息来进行验证(校验用户状态，避免系统攻击)</li>
<li>10.8 创建租赁订单时，前端携带 JWT 发起请求到用户服务接口，后端通过解析 JWT 获取用户信息，验证用户是否登录。</li>
</ol>
<h2 id="文件上传"><a class="header" href="#文件上传">文件上传</a></h2>
<ol>
<li>06.7    实现一个简单的文件上传功能，要求用户可以选择本地的图片进行上传，并在后台进行保存。（商品图片上传失败，提示“上传失败”）</li>
</ol>
<h2 id="验证身份"><a class="header" href="#验证身份">验证身份：</a></h2>
<ol>
<li>08.5 创建租赁订单中需要填入租赁人的身份证和名称并验证是否真实</li>
<li>09.5 前端发送请求到后端API接口，传递身份证和姓名等参数</li>
<li>10.5 在创建租赁订单页面中，前端通过表单输入租赁人的身份证和名称等信息</li>
</ol>
<pre><code class="language-java">
</code></pre>
<h2 id="admin"><a class="header" href="#admin">Admin</a></h2>
<ol>
<li>07.7 使用Admin查看用户服务的准实时日志，并演示实时调整日志等级.</li>
</ol>
<h2 id="总体其他"><a class="header" href="#总体其他">总体其他：</a></h2>
<ol>
<li>01.8 合同录入 – 事务（合同录入提交后，要求根据分期付款方式完成付款计划的录入；确保付款金额精度，使用BigDecimal数据类型）</li>
</ol>
<h1 id="支付中心"><a class="header" href="#支付中心">支付中心</a></h1>
<h2 id="订单列表"><a class="header" href="#订单列表">订单列表：</a></h2>
<ol>
<li>11.1 页面展示：订单列表页面展示正常，包含金额字段和支付状态，使用element-ui实现</li>
<li>12.1 完成页面开发：包含必要字段：金额字段和支付状态(设计订单表，满足三大范式和业务要求，模拟模拟数据要尽量真实。)</li>
<li>13.1 数据库设计和页面开发：订单信息表结构设计规范，完成服务列表页面开发(设计订单表，满足三大范式和业务要求，模拟模拟数据要尽量真实。)</li>
<li>14.1 支付页面设计符合用户习惯，能快速完成支付操作</li>
<li>15.1 设计订单表，满足三大范式和业务要求，并使用真实数据进行模拟.</li>
<li>16.1 使用Java编程语言生成虚拟订单数据，包括订单号、商品信息、金额等。(设计订单表，满足三大范式和业务要求，模拟模拟数据要尽量真实。)</li>
<li>17.1 可以使用随机数或者测试框架来生成模拟数据，确保数据的真实性和合理性</li>
<li>18.1 使用Java编程语言生成虚拟订单数据，可以使用随机数或测试框架来生成模拟数据(设计订单表，满足三大范式和业务要求，模拟模拟数据要尽量真实)</li>
<li>19.1 设计订单表，模拟数据。（设计订单表，满足三大范式和业务要求，模拟模拟数据要尽量真实）</li>
<li>20.1 设计订单表，模拟数据 （设计订单表，满足三大范式和业务要求，模拟模拟数据要尽量真实。）</li>
</ol>
<h2 id="支付宝集成"><a class="header" href="#支付宝集成">支付宝集成：</a></h2>
<ol>
<li>11.2 支付宝SDK集成：参考官方文档进行集成，支付请求正常，能够跳转到支付宝页面</li>
<li>12.2 支付集成：支付宝支付接口正常集成，在订单页生成合法的支付链接。</li>
<li>13.2 支付集成：能够无缝对接支付宝支付</li>
<li>14.2 支付集成：集成支付宝支付接口，完成支付功能</li>
<li>15.2 Spring Boot集成支付宝，实现支付功能的接入和配置.</li>
<li>16.2 使用支付宝提供的SDK或API，结合Spring Boot框架，实现支付宝支付功能的集成</li>
<li>17.2 配置支付宝的商户信息、密钥等参数，并使用HTTPS协议与支付宝服务器进行交互</li>
<li>18.2 在应用的配置文件中配置支付宝的商户信息、密钥等参数，如商户号、应用ID、私钥等</li>
<li>19.2 在支付请求方法中，调用支付宝SDK或API提供的接口，将订单信息发送给支付宝服务器进行支付</li>
<li>20.2 创建一个支付服务类或控制器，实现支付功能的相关方法，如订单创建、支付请求发送和支付结果查询等</li>
</ol>
<h2 id="回调验签"><a class="header" href="#回调验签">回调验签：</a></h2>
<ol>
<li>11.3 支付宝回调处理：支付回调接口正确验签，对验签通过的请求，及时更新本地订单状态</li>
<li>12.3 回调处理：支付宝回调接口验证测试通过，接收支付宝回调，处理回调成功且正确</li>
<li>13.3 支付回调：回调接口能够接收支付宝的回调，验证签名安全，及时更新支付状态</li>
<li>14.3 支付回调：回调接口接收支付宝支付信息，验证确实为支付宝回调后再更新订单状态，确保支付信息的准确性</li>
<li>15.3 处理支付宝回调验签成功后的后续业务逻辑</li>
<li>16.3 在支付宝支付完成后，支付宝会向指定的回调URL发送支付结果通知(回调接口，完成验签功能，并能够修改业务状态)</li>
<li>17.3 在Spring Boot应用中配置回调URL，并实现接收和解析支付宝回调数据的逻辑</li>
<li>18.3 在接收回调通知的方法中，解析支付宝回调数据，可以使用支付宝SDK或API提供的工具类来解析。</li>
<li>18.4 <em>如果支付成功，更新订单状态为已支付，并记录相关支付信息</em></li>
<li>19.3 获取支付宝回调通知中的签名和其他参数，使用支付宝提供的验签规则对回调数据进行验签</li>
<li>20.3 验签成功后，验证订单信息的正确性，并处理支付结果。可以更新订单状态、生成支付记录、发送通知等操作</li>
<li>20.4 <strong>需要注意处理并发情况下的幂等性问题，确保多次回调不会重复处理订单。</strong></li>
</ol>
<h2 id="掉单处理"><a class="header" href="#掉单处理">掉单处理：</a></h2>
<ol>
<li>11.4 对于‘未支付’订单，系统能够定时进行处理，根据支付宝接口返回的状态更新本地订单状态</li>
<li>12.4 对于未能及时处理回调的订单，能够定时查询支付宝，并根据查询结果更新本地订单状态</li>
<li>15.4 实现调单处理功能，修改订单状态以确保数据准确性和一致性</li>
<li>16.4 检查支付宝回调通知中的支付状态，根据实际需求，处理支付成功或支付失败的订单</li>
<li>17.4 可以更新订单状态、生成支付记录、发送通知等操作，确保订单状态与支付宝同步 ？？</li>
<li>18.4 <em>如果支付成功，更新订单状态为已支付，并记录相关支付信息</em></li>
</ol>
<h2 id="关闭订单"><a class="header" href="#关闭订单">关闭订单：</a></h2>
<ol>
<li>11.5 支付关闭处理：对于超过30分钟没有支付成功的订单，及时关闭</li>
<li>14.5 支付通知：支付成功后，可通过短信或邮件通知用户支付成功，确保用户体验</li>
<li>15.5 使用RocketMQ异步消息通知机制，在订单未支付关闭时发送通知消息。</li>
<li>16.5 根据业务需求设置订单的有效支付时间，超过该时间未支付的订单将自动关闭</li>
<li>18.5 <strong>订单创建时，设置订单的有效支付时间，超过该时间未支付的订单将自动关闭</strong></li>
<li>19.5 当订单被关闭时，将相关订单信息发送到RocketMQ的消息队列中</li>
</ol>
<h2 id="退款"><a class="header" href="#退款">退款：</a></h2>
<ol>
<li>13.5 退款功能：已支付的订单，完成退款功能，退款成功修改订单状态</li>
</ol>
<h2 id="支付成功通知"><a class="header" href="#支付成功通知">支付成功通知：</a></h2>
<ol>
<li>12.5 支付成功通知：对于成功支付的客户，及时向客户发送支付成功通知。</li>
<li>13.4 支付状态通知：在支付成功的情况下，能够用短信及时通知客户。</li>
<li>14.4 支付通知：支付成功后，可通过短信或邮件通知用户支付成功，确保用户体验</li>
</ol>
<h2 id="其他"><a class="header" href="#其他">其他：</a></h2>
<ol>
<li>17.5 使用RocketMQ作为消息队列，将未支付关闭的订单信息发送到消息队列中</li>
<li>19.4 <strong>如果支付失败，根据需要进行相应的处理操作，如取消订单、释放库存等</strong></li>
<li>20.5 在消费者中实现相应的逻辑，如记录日志、发送提醒等操作，以便及时处理关闭的订单信息 ？？</li>
</ol>
<h1 id="预约看房"><a class="header" href="#预约看房">预约看房</a></h1>
<h2 id="集成rocketmq"><a class="header" href="#集成rocketmq">集成RocketMQ</a></h2>
<ol>
<li>30.1 集成、配置RocketMQ作为支付模块的消息推送机制，确保消息的可靠传递和处理</li>
</ol>
<h2 id="消息消费"><a class="header" href="#消息消费">消息消费</a></h2>
<ol>
<li>30.2 2.	配置RocketMQ的消费者，订阅&quot;payment_topic&quot;主题，并实现相应的业务逻辑来处理支付相关消息</li>
<li>29.2 配置RocketMQ的消费者，订阅&quot;payment_topic&quot;主题，确保消费者能够接收到支付消息，并实现负载均衡和消费者组管理以提高系统的容错性和扩展性  ？？</li>
<li>28.4 将消息的处理过程异步化，并利用RocketMQ的特性实现并行处理，以提高系统的消息处理速度和吞吐量，优化系统性能和资源利用率  ？？？ </li>
<li>22.2 消息消费者从RocketMQ中异步获取消息，并进行处理，例如发送短信、邮件等通知操作。 ？？？</li>
<li>21.2 接收方的消息消费者从RocketMQ中获取消息，之后通过发送短信、邮件通知用户</li>
</ol>
<h2 id="消息发送"><a class="header" href="#消息发送">消息发送</a></h2>
<ol>
<li>30.3 3.	使用RocketMQ的异步发送方式，将支付消息以消息对象的形式发送到&quot;payment_topic&quot;主题，提高系统的并发能力和响应速度</li>
<li>29.1 配置RocketMQ的生产者，设置主题为&quot;payment_topic&quot;，确保消息的可靠传递，并采用可靠性保证机制增加重试次数和错误处理机制</li>
<li>29.4 4.	将用户下单成功、支付成功或取消订单等事件封装成消息对象，并通过异步发送消息的方式减轻直接同步发送短信或邮件对系统性能的影响，提升系统的稳定性和并发能力</li>
<li>28.1 配置系统以确保用户下单成功、支付成功或取消订单等事件能够触发相应的短信或邮件通知，提升用户体验和服务效果 ？？？？</li>
<li>27.1 通过将相关信息封装成消息对象，并利用RocketMQ的生产者将消息发送到指定的消息主题，实现消息的可靠传递和分发</li>
<li>26.1 确保支付模块中用户下单成功、支付成功或取消订单等事件能够触发消息发送，并在消息消费者端正确处理 ？？ 都要发送这些消息吗？</li>
<li>25.1 当用户下单成功、支付成功或取消订单时，调用RocketMQ的生产者发送相应的支付消息到&quot;payment_topic&quot;</li>
<li>25.4 使用RocketMQ的异步发送方式，将消息发送到&quot;payment_topic&quot;主题</li>
<li>24.1 在用户下单或支付时，将通知信息封装成消息并通过RocketMQ发送至中间件</li>
<li>23.1 用户完成购物行为后，将通知信息封装成消息并通过RocketMQ发送至中间件。。</li>
<li>21.1 使用RocketMQ中间件实现业务解耦，发送短信和邮件通知</li>
<li>30.5 添加消息推送的异常处理机制，如消息发送失败时的错误重试机制和错误日志记录，以保证消息的可靠性和系统稳定性</li>
</ol>
<h3 id="消息发送配置"><a class="header" href="#消息发送配置">消息发送配置：</a></h3>
<ol>
<li>22.1 使用RocketMQ进行同步发送消息，并设置合适的重试次数和超时时间，避免网络波动导致消息重复发送</li>
<li></li>
</ol>
<h2 id="防止重复消费"><a class="header" href="#防止重复消费">防止重复消费</a></h2>
<ol>
<li>30.4 为避免重复消费，使用Redis或其他缓存工具记录已经处理过的消息的唯一标识符，以实现幂等性，确保数据处理的准确性和一致性</li>
<li>29.3 为避免重复消费，消息体中添加唯一标识符如订单号或支付流水号，并在消费端进行去重处理，同时使用幂等性机制确保数据处理的准确性和一致性</li>
<li>28.3 利用RocketMQ内置的消息去重机制和消费者端的幂等性处理功能，避免同一条消息被重复消费，确保数据处理的准确性和一致性  ？？内置消息去重</li>
<li>27.3 在消费者处理消息之前，通过检查消息的唯一标识符或状态，确保同一条消息不会被重复消费，保证数据的一致性和正确性。</li>
<li>26.3 利用RocketMQ内置的消息去重机制，结合消费者端的幂等性处理，确保同一条消息不会被重复消费，保证消息的准确性和一致性 ？？ 内置消息去重</li>
<li>25.3 可以使用Redis等缓存工具记录已经处理过的消息的唯一标识符，以防止重复消费</li>
<li>23.3 在消息消费过程中，注意避免重复消费问题，以避免引发业务异常</li>
<li>22.4 为消息添加唯一标识如订单号、支付流水号作为消息ID，确保消息仅被处理一次，避免重复消费</li>
</ol>
<h2 id="防止消息丢失"><a class="header" href="#防止消息丢失">防止消息丢失</a></h2>
<ol>
<li>28.2 正确配置RocketMQ的生产者和消费者实例，以确保消息不会在传递过程中丢失，增强系统的消息可靠性和稳定性  ？？</li>
<li>27.2 RocketMQ采用高可靠的消息传递机制，确保消息能够准确地传递，且不会丢失，提供可靠性保障 ???</li>
<li>26.2 通过将消息发送到RocketMQ消息队列中，确保消息不会丢失，并能够在网络异常或其他问题后恢复正常消费</li>
</ol>
<h2 id="异步"><a class="header" href="#异步">异步？</a></h2>
<ol>
<li>27.4 将短信发送或邮件发送的动作解耦至异步线程中，将发送操作与主线程分离，提高系统的响应速度和并发能力，优化用户体验和系统性能  ？？</li>
<li>26.4 利用RocketMQ的异步发送特性，将短信发送或邮件发送的动作从主线程中解耦，提高系统的响应速度和并发能力，优化用户体验和系统性能</li>
</ol>
<h2 id="消息堆积"><a class="header" href="#消息堆积">消息堆积</a></h2>
<ol>
<li>24.3 消息堆积解决。 增加消息消费线程数：通过增加消息消费线程数，可以提高消息消费速度，减少消息堆积的可能性</li>
<li>22.3 增加消费者数量以提高消息消费速度，降低消息堆积的潜在风险</li>
<li>21.3 通过启用多个消息消费者实例进行并行处理，解决消息积压问题</li>
</ol>
<h2 id="消息补偿"><a class="header" href="#消息补偿">消息补偿</a></h2>
<ol>
<li>24.4 消息补偿。：在消息消费过程中，对于处理失败的消息，进行一定次数的重试操作，并记录错误日志。</li>
<li>23.4 实现消息消费补偿机制，用于在消息消费过程中出现异常时进行重试操作，确保消息的可靠性</li>
<li>21.4 在消息消费过程中出现异常时，通过重试机制保证业务正确性</li>
</ol>
<h2 id="异步2"><a class="header" href="#异步2">异步2</a></h2>
<ol>
<li>24.2 消息接收的设计。 消息消费者从RocketMQ中获取消息，将消息异步处理，例如发送短信、邮件通知用户</li>
<li>23.2 消息消费者从RocketMQ中异步获取消息，并进行相应的处理，如发送短信、邮件通知用户。???</li>
</ol>
<h2 id="消费者集群"><a class="header" href="#消费者集群">消费者集群</a></h2>
<ol>
<li>25.2 将RocketMQ的消费者消费模式设置为集群模式，确保多个消费者能够同时消费消息，提高可靠性  ??</li>
</ol>
<h2 id="其他-1"><a class="header" href="#其他-1">其他</a></h2>
<ol>
<li>21.5 消息推送系统可靠性设计（4分）：包括消息持久化、重试策略和故障恢复机制，确保系统的可靠性  ？？？</li>
<li>22.5	消息可靠性保障（3分）：使用持久化机制存储消息，结合监控手段和故障恢复机制，保证消息推送系统的可靠性</li>
<li>23.5 对于有序消息，考虑实现消息的顺序处理，确保消息按照特定顺序被消费 ???</li>
<li>24.5 建立消息监控机制，实时监测消息堆积情况，并设置相应的报警机制，及时发现和处理异常情况 ？？？</li>
<li>25.5 设置RocketMQ的消息可靠性保障机制，如开启同步刷盘和持久化，确保消息不会丢失。</li>
<li>26.5 配置RocketMQ的消费者端负载均衡策略，确保多个消费者能够均衡消费消息，提高系统的可伸缩性和稳定性</li>
<li>27.5 利用RocketMQ的顺序消息传递特性，确保同一个消息队列中的消息按照发送顺序进行消费，保证消息的顺序性，适用于有序处理的场景</li>
<li>28.5 结合RocketMQ提供的错误消息处理机制和重试策略，及时检测和处理消息处理过程中的异常情况，并进行恰当的重试，以确保系统的稳定运行和消息的可靠发送</li>
<li>29.5 在RocketMQ中配置适当的消息存储策略、消息投递超时时间以及消息重试次数，以确保消息的持久化存储、可靠性投递和容错处理，防止消息丢失或延迟。</li>
</ol>
<h1 id="外卖抢单"><a class="header" href="#外卖抢单">外卖抢单</a></h1>
<h2 id="线程池的使用"><a class="header" href="#线程池的使用">线程池的使用</a></h2>
<ol>
<li>40.1 通过合理的线程池参数配置，控制线程数量，避免资源耗尽和性能下降(请自定义线程池，并合理设置核心参数，以控制线程数量，避免线程过多而导致系统整体性能下降)</li>
<li>39.1 使用线程池管理和调度线程，确保外卖抢单系统能够高效处理大量请求(请自定义线程池，并设置适当的核心参数，避免线程数量过多导致系统整体性能下降)</li>
</ol>
<pre><code class="language-java">//初始化线程池 
@Configuration
public class ThreadPoolConfig {

    @Bean
    public ThreadPoolTaskExecutor executor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setMaxPoolSize(2);//线程池最多有2个线程
        executor.setCorePoolSize(1);//核心线程数为1
        executor.setThreadNamePrefix(&quot;*_*&quot;);//线程名称前缀
        executor.setQueueCapacity(100);//线程池等候队列
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());//拒绝策略
        executor.initialize();//初始化
        return executor;
    }
}
</code></pre>
<ol>
<li>38.1 使用Java多线程技术处理外卖抢单模块的并发请求（请自定义线程池，并设置适当的核心参数，以避免线程数量过多对系统整体性能造成负面影响）</li>
<li>35.1 基于Spring Boot框架构建外卖抢单模块，使用Java多线程技术处理并发请求（自定义线程池，设置核心参数，避免线程过多，影响系统整体性能）</li>
</ol>
<pre><code class="language-java">@RequestMapping(&quot;/process&quot;)
public Result&lt;Boolean&gt; createOrder(Book book) {
    executor.execute(() -&gt; {//使用多线程处理创建订单请求
        Order order = createOrder(book, 1,1);
        orderService.save(order);
    });
    return Result.ok(true);
}
</code></pre>
<ol>
<li>34.2 使用线程池生成外卖订单（使用自定义线程池创建多个线程，并在每个线程中生成多个外卖订单。请设置合理的线程池参数，避免线程数量过多导致系统整体性能下降）</li>
<li>33.3 模拟用户产生大量订单 （使用Java多线程技术实现模拟用户并发产生大量订单。在实现过程中，请自定义线程池，并设置合理的核心参数，以避免线程数量过多导致系统性能下降）</li>
<li>31.2 创建多个线程，并在每个线程中生成多个外卖订单</li>
</ol>
<pre><code class="language-java">    @RequestMapping(&quot;/creat_order&quot;)
    public Result&lt;Boolean&gt; creatOrder() {
        Book book = new Book();
        book.setId(1);
        book.setPrice(BigDecimal.TEN);
        for( int i=0;i&lt;3; i++) {
            executor.execute(() -&gt; {
                while(true) {
                    Order order = createOrder(book,1, 1);
                    orderService.save(order);
                    System.out.println(&quot;create order: &quot; + order.toString());
                    try {
                        Thread.sleep(RandomUtil.randomInt(100,2000));
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }

            });
        }
        return Result.ok(true);
    }
</code></pre>
<h2 id="限流"><a class="header" href="#限流">限流</a></h2>
<pre><code class="language-yaml">
</code></pre>
<ol>
<li>40.2 当达到限流阈值时，返回合适的错误码或页面提示用户稍后再试 (请使用Hystrix或Gateway网关等技术进行服务降级，以避免系统崩溃，并返回适当的错误码或页面提示，告知用户稍后再试) ？？ 怎么实现</li>
<li>39.2 设置适当的限流策略，例如限制API接口每秒请求数或并发请求数(使用Gateway网关对外卖抢单系统进行服务降级，以防止系统崩溃，并确保在高负载情况下系统的正常运行)</li>
<li>38.2 基于网关做限流处理，以防止系统负载过高（通过配置网关进行限流，以确保系统在高负载情况下不会受到过多请求的影响，保持系统的稳定性）</li>
<li>37.2 自定义线程池和设置核心参数，在外卖抢单系统中避免线程过多，影响系统整体性能（通过自定义线程池并设置核心参数来管理外卖抢单系统中的线程，以避免线程过多对系统整体性能造成影响） ？？？</li>
<li>36.2 设置合理的限流策略，如限制API接口每秒请求数或并发请求数 （请描述如何设置合理的限流策略，例如通过Hystrix或Gateway网关进行服务降级，以避免系统崩溃）</li>
<li>35.2 使用分布式限流对外卖抢单接口进行访问频率的限制，防止系统负载过高（使用Hystrix或Gateway网关进行服务降级，避免系统崩溃）</li>
<li>33.2 限制订单服务的访问频率 （为了控制订单服务的访问频率，需要设定最大的访问次数和并发数量。请确保订单服务每分钟最多处理1800次访问请求，并发数量不超过200）</li>
<li>32.4 针对高峰时期流量过大可能引起的系统瘫痪问题实现相应解决方案 ？？？</li>
<li>31.4 针对高峰时期流量过大可能引起的系统瘫痪问题实现相应解决方案</li>
</ol>
<h2 id="超卖"><a class="header" href="#超卖">超卖</a></h2>
<ol>
<li>40.3 根据订单状态和库存信息，使用Redis防止商品超卖 (请根据订单状态和库存信息，使用Redis等缓存技术，实现商品超卖的防止机制，确保每个订单都有足够的库存进行抢购) </li>
<li>39.3 使用Redis的原子操作，实现防止超卖问题的解决方案 (探索并实施基于Redis的原子操作，确保每个订单的抢单过程中不会出现超卖的情况)</li>
<li>38.3 使用Redis缓存热点数据，提高读取速度，减轻数据库压力 （使用Redis作为缓存，存储外卖抢单系统的热点数据，以加快数据的读取速度，减少对数据库的访问，从而减轻数据库的压力）</li>
<li>37.3 当外卖抢单系统达到限流阈值时，如何返回适当的错误码或页面提示用户稍后再试（在外卖抢单系统中如何通过Hystrix或Gateway网关进行服务降级，以避免系统崩溃，并给出相应的错误码或页面提示，在达到限流阈值时引导用户稍后重试）</li>
<li>36.3 在高并发场景下，使用Redis的原子操作（如incr/decr）实现防止超卖问题的解决方案（请详细说明在高并发场景下，如何利用Redis的原子操作（如incr/decr）来有效解决外卖抢单系统中可能出现的超卖问题）</li>
<li>34.3 保证订单抢单的线程安全(为了防止多个用户同时抢购同一个订单，需要实现线程安全机制。请说明你打算如何保证订单抢单的安全性，确保每个订单只能被一个用户抢到) ??? 怎么说明</li>
<li>31.3 考虑多个外卖员同时抢某订单的情况，防止某订单被多人抢到</li>
</ol>
<h2 id="jmeter"><a class="header" href="#jmeter">JMeter</a></h2>
<ol>
<li>40.4 使用JMeter工具，分析测试结果(请使用JMeter工具对系统进行性能测试，分析测试结果，评估系统的吞吐量、并发能力和响应时间等指标，以便进一步优化系统性能)</li>
<li>39.4 评估外卖抢单系统的接口性能和稳定性，包括响应时间、吞吐量和错误率等指标(通过性能测试工具Jmetter，对外卖抢单系统进行接口性能和稳定性测试，分析关键指标包括响应时间、吞吐量和错误率等，以评估系统的性能和稳定性)</li>
<li>38.4 使用JMeter工具创建模拟请求，配置合理的线程数和并发用户数来模拟高峰期访（使用JMeter工具，配置合理的线程数和并发用户数，模拟外卖抢单系统在高峰期的访问情况，以评估系统的性能和可靠性）</li>
<li>37.4 根据订单状态和库存信息，使用Redis维护每个商品的可售数量，并在抢单时进行原子操作，保证库存的准确性（如何利用Redis缓存热点数据，在外卖抢单系统中根据订单状态和库存信息维护每个商品的可售数量，并确保在抢单过程中进行原子操作，以保证库存的准确性）</li>
<li>36.4 使用JMeter测试外卖抢单系统的接口性能 （请介绍如何使用JMeter工具对外卖抢单系统的接口性能进行测试，包括测试的目标、方法和常见指标等） ？？</li>
<li>35.4 使用JMeter工具创建模拟请求，配置合理的线程数和并发用户数来模拟高峰期访问</li>
<li>37.5 使用JMeter工具对外卖抢单系统进行性能分析和优化（请阐述如何使用JMeter工具分析外卖抢单系统的性能，并提出相应的优化方案，例如通过调整线程池大小、数据库连接池参数等来提升系统的处理能力）</li>
</ol>
<h2 id="事务"><a class="header" href="#事务">事务</a></h2>
<ol>
<li>37.1 使用数据库事务机制确保数据的一致性和并发操作的正确性 （利用数据库事务机制来管理外卖抢单系统中的数据操作，以确保数据的一致性和并发操作的正确性）</li>
</ol>
<h2 id="缓存"><a class="header" href="#缓存">缓存</a></h2>
<ol>
<li>35.3 商品加载到Redis缓存中，提高读取速度，减轻数据库压力</li>
<li>32.2 完成产品信息的缓存代码 只需要完成后端代码，缓存信息存放在redis中</li>
</ol>
<h2 id="缓存一致性"><a class="header" href="#缓存一致性">缓存一致性</a></h2>
<ol>
<li>32.3 完成产品更新功能。考虑到产品运行在并发请求中，请实现一种方案，确保缓存和数据库中的数据保持一致</li>
</ol>
<h2 id="订单关闭"><a class="header" href="#订单关闭">订单关闭</a></h2>
<ol>
<li>34.4 编写定时任务自动删除过期订单（编写定时任务，用于自动删除过期的订单。请设定合适的时间间隔，确保系统能够及时清理过期的订单数据，并释放相关资源）</li>
<li>33.1 为了保证订单系统的数据一致性，需要及时关闭未支付订单。请自行设计数据库表结构，满足三大范式要求，并确保数据一致性。订单创建后，如果30分钟内未完成支付，则需要将该订单状态设置为已关闭</li>
</ol>
<h2 id="建表"><a class="header" href="#建表">建表</a></h2>
<ol>
<li>36.1 设计合适的数据库表结构，准备用于保存订单的数据表（设计合适的数据库表结构，满足三大范式要求，并解释如何确保数据的一致性）？？？</li>
<li>34.1 创建外卖订单表（请使用Java代码生成外卖订单表，包含以下字段：订单ID、价格、送餐地址、目的地、创建时间和状态等。你可以自行建表，也可以参考提供的takeaway.sql文件，确保满足三大范式要求并保证数据一致性）</li>
<li>32.1 创建产品表和相应的代码 参考上文中的“product.sql”创建订单表。并生成相应的java代码以实现对该表操作（自行建表，可以参考product.sql，满足三大范式要求，保证数据一致性）</li>
<li>31.1 创建外卖订单表和相应的代码 （5分）参考上文中的“takeaway.sql”创建订单表。并生成相应的java代码以实现对该表操作（自行建表，可以参考takeaway.sql，满足三大范式要求，保证数据一致性）</li>
</ol>
<h2 id="其他-2"><a class="header" href="#其他-2">其他</a></h2>
<ol>
<li>33.4 使用Postman实现创建订单，对订单创建请求进行安全验证 检验是否携带正确的token，只有带有正确token的请求才能创建成功</li>
</ol>
<h2 id="什么鬼"><a class="header" href="#什么鬼">什么鬼？</a></h2>
<ol>
<li>33.5 在使用支付宝接口进行订单处理时，为了确保数据的完整性和安全性，需要进行验签操作。请说明验证签名的步骤，并确保只有通过验签的请求才能被认为是有效的   ？？？说明</li>
<li>34.5 在使用支付宝接口进行订单处理时，为了确保数据的完整性和安全性，需要进行验签操作。请说明验证签名的步骤，并确保只有通过验签的请求才能被认为是有效的</li>
<li>36.5 请说明如何使用JMeter工具对外卖抢单系统的稳定性进行评估，包括模拟高负载、长时间运行和异常情况等测试场景。 ？？？ 异常情况是指？？</li>
<li>38.5 优化外卖抢单系统的性能和用户体验（MQ异步处理订单，以提高外卖抢单系统的性能和用户体验） ？？？</li>
<li>39.5 优化外卖抢单系统的性能和用户体验 (使用Redis缓存热点数据，以提高外卖抢单系统的性能和用户体验)</li>
<li>40.5 如何提高系统性能和用户体验(使用缓存技术或异步处理或负载均衡等手段)</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="19_企业级测试与解决方案.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="project/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="19_企业级测试与解决方案.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="project/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>


    </body>
</html>
